<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta name="author" content="Patrick Thomson" />
        <link rel="stylesheet" type="text/css" href="../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>
            adventures in uncertainty: Fluent Polymorphism with Visible Type Applications
        </title>
    </head>


    <body>
        <div id="header">
            <a href="../">home</a>
            <a href="../archive.html">archive</a>
            <a href="../about.html">about</a>
            <a href="../contact.html">contact</a>
        </div>
        <div id="content">
            <article>
                <h1>Fluent Polymorphism with Visible Type Applications</h1>
                
                  <h2>2018-12-26</h2>
                
                <section>
                    <blockquote>
<p>I refer to those genera which have sometimes been called “polymorphic”, in which the species present an inordinate amount of variation; and hardly two naturalists can agree which forms to rank as species and which as varieties.</p>
<p>— Charles Darwin, <em>The Origin of Species</em></p>
</blockquote>
<p>Haskell is my favorite programming language, but it is not simple—a language with a strong static type system and non-strict semantics is one that must deal in subtlety and nuance. However, typeclasses, one of Haskell’s most fundamental features, admit a surprisingly-simple implementation, one drastically simpler than the corresponding features of ALGOL-style scripting languages. This piece aims to be a brief, high-level overview of how typeclasses are resolved at compile-time, how they’re invoked at runtime, and how the <code>-XTypeApplications</code> extension to GHC provides a more granular approach for such resultion, one that enables sophisticated and subtle APIs in real-world problems.</p>
<h1 id="fewer-words-more-meanings">fewer words, more meanings</h1>
<p>A computer program is a conversation between a human and a machine. A limited conversation, yes, and one often marred by profanity and frustration, but one informed in structure and style by human language, both the languages with which we communicate with our fellow humans and the inner language with which we organize our thoughts. One of the defining features of human language is the ability for one word to mean many things: one signifier, many referents. We can fix a car, we can fix a breakfast, and we can fix an election—though these activities are substantially different, the speakers of English have collectively decided that there is an underlying similarity between them, and that the word ‘fix’ captures this similarity, giving us one versatile word rather than three<span><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle" /><span class="sidenote">The Oxford English Dictionary <a href="https://www.nytimes.com/2011/05/29/opinion/29winchester.html">asserts</a> that the word ‘run’ has the most definitions of any word in the language; the verb alone has 645 meanings. If every such meaning were given its own word, it would take more than four months to learn them all, assuming that the average person can learn ~5 words per day.<br />
<br />
</span></span> situation-specific ones. In other words, spoken language provides <em>polysemy</em>–the ability for a word or phrase to refer to different things based on context. Wordplay, metaphor, simile, metonymy, synecdoche: language, and by extension the whole of human thought, delights in polysemy’s nuance.</p>
<p>In programming, we refer to this phenomenon as <em>polymorphism</em>. Computers, in contrast with humans, do not delight in polymorphism. Resolving the meaning of a polymorphic statement entails choice, and computers are notoriously bad at making correct choices in the absence of human supervision. But effective use of polymorphism is often, if not always, at the heart of well-written code, so nearly all programming languages<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">Even C has <code>_Generic</code> macros now, which provide a form of compile-time polymorphism.<br />
<br />
</span></span> provide means for polymorphism. Because teaching computers to make predictable, sensible choices is a complicated prospect, most programming languages use complicated systems to resolve polymorphism:</p>
<ul>
<li>Python’s object system, providing Simula-style<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">Unless you use <code>@property</code>, which is much closer to the Smalltalk school of thinking than Simula.<br />
<br />
</span></span> object-orientation with multiple inheritance, uses <a href="https://en.wikipedia.org/wiki/C3_linearization">C3 linearization</a> to resolve a method invoked on an object.</li>
<li>Ruby’s object system, a weird hybrid of Smalltalk-style class-based OO and Self-style prototypical OO, provides <a href="https://gist.github.com/damien-roche/351bf4e7991449714533">its own algorithm</a>, one capable of expressing sophisticated, if oft-surprising, polymorphism.</li>
<li>Common Lisp, in keeping with its ethos of flexibility, provides an object system in which the resolution of polymorphism is entirely customizable at runtime. There’s a <a href="https://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744">whole book</a> about this.</li>
</ul>
<p>Haskell is different. For all its reputation for being a language that is difficult to learn<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle" /><span class="sidenote">(a reputation that is sometimes unfair and sometimes extremely well-deserved)<br />
<br />
</span></span>, its system for providing polymorphism is simple, so simple that when I first learned of it I felt vaguely cheated in some way. Let’s take the notion of equality–<code>(==)</code>, one of the most common polymorphic functions–and explore how Haskell represents that, both to the programmer and within its runtime system. (If you’re already fluent in Haskell and familiar with dictionary-passing style, you might want to skip ahead to the next section, in which I start playing around with explicit type applications.)</p>
<h1 id="equalunequalfun-equal">equal/unequal/fun-equal</h1>
<p>Polymorphism is a great and necessary thing, but how should a compiler or interpreter implement it? From an object-oriented perspective, in which code and data are intertwined, the most straightforward solution to provide is to have some sort of lookup table (usually called a ‘vtable’, C++ argot for ‘virtual method table’) present in the in-memory layout of a given object. Due to the fact that Haskell lacks objects but possesses a strong type system, vtables become unnecessary: the target of polymorphic calls is <em>always</em> resolvable at compile time. If, at compile time, your program contains a type variable that cannot be resolved, GHC rejects the program with an error.</p>
<p>Let’s take a look at one of Haskell’s most fundamental typeclasses and the mechanisms with which GHC compiles this typeclass into its intermediate language, which lacks typeclasses.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>Haskell’s equality operator is implemented atop the <code>Eq</code> typeclass. Even if you don’t speak Haskell, this should look reasonably familiar if you’ve ever looked at <code>Equatable</code> in Java or IEquatable in C#.</p>
<p>This interface provides a polymorphic function <code>(==)</code>, one that compares two values (of the same type) for equality. It is polymorphic in one type variable, <code>a</code> in the above declaration. We can use this function over any type that implements the <code>Eq</code> interface, as long as <code>a</code> can be resolved, at some point, to a concrete type like <code>Int</code> or <code>String</code>. We can write a useful function with <code>Eq</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">allEqual ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>allEqual []       <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>allEqual (h<span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">all</span> (<span class="op">==</span> h) rest</span></code></pre></div>
<p>Here we define an <code>allEqual</code> function that is polymorphic in its argument, taking a list of any values implementing <code>Eq</code>. The <em>constraint</em>, on the left-hand-side of the <code>=&gt;</code>, introduces a type variable named <code>a</code>, corresponding to a given type that implements the <code>Eq</code> class. (We call this a ‘constraint’ because it constrains the set of types that this function will accept.)</p>
<p>Here’s the secret to Haskell’s implementation of polymorphism: <strong>during compilation, GHC turns that <code>=&gt;</code> into an <code>-&gt;</code>.</strong> That’s right: a constraint on a function becomes a parameter to that function<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle" /><span class="sidenote">An interesting consequence of this is that you can use <code>=&gt;</code> in more than one place in a type signature: the signatures <code>Ord a =&gt; Ord b =&gt; a -&gt; b -&gt; Bool</code> and <code>(Ord a, Ord b) =&gt; a -&gt; b -&gt; Bool</code> are equally valid.<br />
<br />
</span></span>. <code>allEqual</code> is a function that takes one argument, but from the runtime’s perspective it takes two. This new argument is called a <em>dictionary</em>, and the under-the-covers application of dictionaries to polymorphic functions is called <em>dictionary-passing style</em><span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle" /><span class="sidenote">Because GHC’s type system is significantly more featureful than the type system specified in the Haskell Report, the details of its typeclass resolution are a bit more complicated—things like type families introduce subtleties to the dictionary-passing approach. You could, however, sit down and implement your own Haskell2010 compiler with dictionary-passing style.<br />
<br />
</span></span>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">EqDict</span> a <span class="ot">=</span> <span class="dt">EqDict</span> {<span class="ot"> dictEqual ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</span></code></pre></div>
<p>Under the dictionary-passing model, this typeclass is represented in a manner similar to this Haskell data type—a data structure, parameterized in terms of an input type, that holds references to concrete implementations of the methods referenced in the typeclass.</p>
<p>When types are correctly resolved, an <code>EqDict Int</code> dictionary will contain in its <code>dictEqual</code> field the correct implementation of <code>==</code> for <code>Int</code> values. <em>If, during compilation, a polymorphic type cannot be instantiated or inferred to be a concrete type, typechecking will fail.</em> This is the source of the dreaded <code>Ambiguous type variable</code> error from GHC: if a given type variable cannot be resolved to a concrete type, we can’t build an <code>EqDict</code> for it, since we don’t know how to fill in the <code>dictEqual</code> field.</p>
<p>This has some resemblance to vtables from object-oriented language, but there’s a crucial difference: though a data type may implement <code>Eq</code>, there is no <code>EqDict</code> carried around within its in-memory representation. Though an <code>Int</code> may implement dozens of different interfaces, I can pass them around as data and data alone: polymorphism is <em>provided at call-sites</em>, not shoehorned into data structures themselves.</p>
<p>Let’s consider how this would look if Haskell didn’t have typeclasses:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">allEqualDictionary ::</span> <span class="dt">EqDict</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>allEqualDictionary dict [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>allEqualDictionary dict (h<span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">all</span> ((dictEqual dict) h) rest</span></code></pre></div>
<p>This function is equivalent in functionality to our previous one, but we’d have to build an <code>EqDict</code> every time we invoked the <code>(==)</code> function, which is both tedious and inefficient. GHC takes care of this for us.</p>
<p>That’s it. No fancy algorithm, no superclasses or metaclasses or prototypes, no vtables attached to data structures, no runtime type inference. Just a record type for every typeclass. Remarkable.</p>
<h1 id="parental-advisory-ambiguous-content">parental advisory: ambiguous content</h1>
<p>I mentioned that GHC will reject programs in which it cannot infer a concrete type for every type variable. So what do you do if GHC can’t infer which type to use (or, in other words, which dictionary to pass)? Well, the simplest option is to use an inline type signature.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">let</span> tenThousand <span class="ot">=</span> <span class="dv">10000</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">-- Ambiguous: it's unclear which 'Num' instance to return from fromIntegral.</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="fu">print</span> (<span class="fu">fromIntegral</span> tenThousand)</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">-- Unambiguous: by narrowing the 'Num' instance to that of 'Word32', we</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">-- know which Num and Show instances to use.</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="fu">print</span> (<span class="fu">fromIntegral</span><span class="ot"> tenThousand ::</span> <span class="dt">Word32</span>)</span></code></pre></div>
<p>If we have some constraint–<code>Eq a</code>, let’s say–we can, with a type signature, specify an explicit, rather than inferred, type should use. The number 10,000 goes from a polymorphic value to a concrete <code>Integer</code>. Similarly, the result of <code>fromIntegral</code>, which yields a value of some type implementing the <code>Integral</code> typeclass, is established as a <code>Word32</code> with the explicit signature <code>:: Word32</code>. (You can’t go the other way: it is not legal to “upcast” a function of <code>Int -&gt; Int</code> to <code>Num a =&gt; a -&gt; a</code>).</p>
<p>Ultimately, what we’re <em>doing</em> with this inline type signature is specifying otherwise-unresolvable entries in the given call’s dictionary. Thus, a question: what if, instead of inserting inline type signatures, we had a more-general syntax specifically for this purpose, one that allowed us to state exactly which types should be passed to a given function’s dictionary?</p>
<p>Good news: we do. The <code>-XTypeApplications</code> extension to GHC Haskell landed in GHC 8.0, providing syntax for <em>visible type applications</em>, as described in the eponymous and <a href="https://www.seas.upenn.edu/~sweirich/papers/type-app-extended.pdf">excellent paper</a> by Richard Eisenberg, Stephanie Weirich, and Hamidhasan Ahmed.</p>
<h1 id="a-notation-for-annotation">a notation for annotation</h1>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">allEqual ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>This was the type of our <code>allEqual</code> function above. When GHC has compiled Haskell down to its intermediate language, we know that this <code>Eq a</code> parameter will be represented with a dictionary.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- n.b.: This is not legal Haskell syntax</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">allEqual ::</span> <span class="op">@</span><span class="dt">EqDict</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>In this pseudo-Haskell syntax, we use the <code>@</code> prefix to mean “a dictionary for”. If we applied <code>allEqual</code> to a list of <code>Char</code> values, the dictionary passed in would be represented as <code>@Char</code>.</p>
<p>The purpose of the <code>-XTypeApplications</code> extension is to let us, using the <code>@</code> syntax, <em>manually specify</em> the type and dictionary used for a given polymorphic call. (Unlike inline type signatures, explicit type annotations cannot be applied to values: they are always part of function calls.)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>λ <span class="op">:</span>set <span class="op">-</span><span class="dt">XTypeApplications</span> <span class="co">-- or {-# LANGUAGE TypeApplications #-}</span></span></code></pre></div>
<p>And since explicit type applications are not part of Haskell 2010, we have to toggle their presence with a <code>LANGUAGE</code> pragma. When we turn this on, we can start with a simple example.</p>
<pre class="example"><code>λ :t 100
100 :: Num p =&gt; p
</code></pre>
<p>An interesting feature of Haskell is that its integer literals are untyped. This means that, in the absence of any other calls that might resolve a given numeric literal to a concrete type such as <code>Int</code>, <code>Integer</code>, or <code>Double</code>, its type is polymorphic: that <code>100</code> can stand for any type<span><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle" /><span class="sidenote">such as the excellent <a href="https://wiki.haskell.org/Num_instance_for_functions"><code>Num</code> instance</a> for functions<br />
<br />
</span></span> that implements the <code>Num</code> interface.</p>
<p>#+BEGIN<sub>EXAMPLE</sub> haskell λ :t id <span class="citation" data-cites="Int32">@Int32</span> 100 id <span class="citation" data-cites="Int32">@Int32</span> 100 :: Int32</p>
<p>#+END<sub>EXAMPLE</sub> But when we use the <code>id</code> function and a type application, we can constrain the type that <code>id</code> takes, forcing that literal to be a given type. Given that you can’t apply a type application directly to a literal (type applications only work in function contexts), this hardly seems a benefit over using an explicit type signature, no call to <code>id</code> required:</p>
<p>#+BEGIN<sub>EXAMPLE</sub> haskell λ :t (100 :: Int32) 100 :: Int32</p>
<p>#+END<sub>EXAMPLE</sub> Yet <code>TypeApplications</code>’s usefulness is more apparent in a more polymorphic context. Let’s define a rather unprincipled function to demonstrate this.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">unprincipledAdd ::</span> (<span class="dt">Integral</span> a, <span class="dt">Integral</span> b)</span>
<span id="cb10-2"><a href="#cb10-2"></a>                <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb10-3"><a href="#cb10-3"></a>unprincipledAdd a b <span class="ot">=</span> <span class="fu">fromIntegral</span> (a <span class="op">+</span> b)</span></code></pre></div>
<p><code>unprincipledAdd</code> takes two values of some <code>Integral</code> type and adds them together, coercing the result of that addition into some other type implementing <code>Integral</code> . This is fine to define, but at invocations of <code>unprincipledAdd</code> we may run into trouble.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="fu">print</span> (unprincipledAdd <span class="dv">1</span> <span class="dv">2</span>)</span></code></pre></div>
<p>If we write the above call in Haskell code<span><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle" /><span class="sidenote">If you try this upcoming code sample in <code>ghci</code>, it will execute without error, whereas if you try it in a standard Haskell source file it will fail to typecheck. This is because <code>ghci</code> uses a set of <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#type-defaulting-in-ghci">type defaulting</a> rules to resolve a sensible type for polymorphic literals. This feature is actually present in Haskell itself (<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3">section 4.3.4</a> of the Haskell Report has the gory details), but is tremendously obscure and rarely, if ever, seen in real-world code.<br />
<br />
</span></span>, GHC will reject our program, as it cannot figure out what type to resolve for the numeric literals: they could be <code>Int32</code>, <code>Integer</code>, <code>Word16</code>, <code>Double</code>—anything that implements the <code>Num</code> typeclass.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="fu">print</span> (unprincipledAdd <span class="op">@</span><span class="dt">Int</span> <span class="op">@</span><span class="dt">Word</span> <span class="dv">1</span> <span class="dv">2</span>)</span></code></pre></div>
<p>In contrast, the call with explicit type applications will typecheck successfully. The above call can be expressed with explicit type signatures, too:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="fu">print</span> ((unprincipledAdd (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>))<span class="ot"> ::</span> <span class="dt">Word</span>)</span></code></pre></div>
<p>In contrast with our previous example, I’d argue that the explicit type signatures make this version significantly more difficult to read.</p>
<p>Visibile type applications also play nice with inference:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>someFunction <span class="op">@</span><span class="dt">Int</span> <span class="op">@</span>_ <span class="op">@</span>(<span class="dt">Vector</span> _) a b c</span></code></pre></div>
<p>The <code>@_</code> syntax, like the <code>_</code> character in a pattern-matching context, means something akin to a wildcard: it lets us rely on the type inference engine to infer a particular type variable, while letting us continue on and specify the values for further parameters. Here our invocation means “the first parameter of this function is applied to <code>Int</code>, the second should be inferred by the type system, and the third is some <code>Vector</code> containing a type that I want inferred.”</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a>someFunction <span class="op">@</span><span class="dt">Int</span> a b c</span></code></pre></div>
<p>If we only need to specify the first N type variables, leaving the subsequent values up to the type inference engine, we need only provide as many variables as we need: GHC will apply the wildcard application to all further type variables.</p>
<h1 id="special-effects">special effects</h1>
<p>Visible type applications are essential for idiomatic use of the <a href="https://hackage.haskell.org/package/fused-effects"><code>fused-effects</code></a> library. While a complete explanation of the use of and motivation behind effects systems is out of scope for this particular blog post, it suffices to consider an effectful computation that has access to two stateful variables, of type <code>Foo</code> and <code>Bar</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">effectful ::</span> (<span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">Foo</span>) sig, <span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">Bar</span>) sig, <span class="dt">Carrier</span> m) <span class="ot">=&gt;</span> m ()</span></code></pre></div>
<p><code>fused-effects</code> provides <code>get</code> and <code>put</code> functions that manipulate any type provided by the <code>Member State</code> constraints. Though pleasingly polymorphic, this can lead to situations that stump the type checker:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">stringRepr ::</span> (<span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">Foo</span>) sig, <span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">Bar</span>) sig, <span class="dt">Carrier</span> m) <span class="ot">=&gt;</span> m <span class="dt">String</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>stringRepr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  var <span class="ot">&lt;-</span> get</span>
<span id="cb17-4"><a href="#cb17-4"></a>  <span class="fu">pure</span> (<span class="fu">show</span> var)</span></code></pre></div>
<p>It is not clear from this code whether the <code>get</code> invocation should return a <code>Foo</code> or a <code>Bar</code>—in other words, whether it should use the <code>State Foo</code> constraint or the <code>State Bar</code> constraint. A visible type application clears that right up.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a>stringRepr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>  var <span class="ot">&lt;-</span> get <span class="op">@</span><span class="dt">Foo</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>  <span class="fu">pure</span> (<span class="fu">show</span> var)</span></code></pre></div>
<p>Thanks to the visible type application (more readable than an explicit signature around the <code>get</code> invocation or, with <code>-XScopedTypeVariables</code>, around <code>var</code>), the typechecker is no longer stuck, and we can continue on our merry way.</p>
<h1 id="conclusion-c-c"><code>Conclusion c =&gt; c</code></h1>
<p>Most languages have simple evaluation semantics and complicated polymorphism semantics. Haskell is the opposite: its non-strict evaluation strategy is subtle, but its strategy for resolving polymorphic functions is simple, and places no requirements on the memory layout of Haskell data structures, in contrast with most object-oriented languages.</p>
<p>It’s insights like these that prove the worth and merit of exploring unconventional programming languages. While object-oriented programming has been one of the great success stories in all of software engineering, traditional OOP approaches often entail surprising restrictions. In this way, the despairing air of the Darwin quote that opened this piece is not applicable: given the richness of polymorphism in human language, there are surprisingly simple ways to embed it within a programming language. I’m sure he’d be relieved to know that. Or possibly not. The man was kind of a downer.</p>
<p><em>I’d like to thank Ayman Nadeem, Peter Berger, Rick Winfrey, and Kenny Foner for reviewing drafts of this post.</em></p>
                </section>
            </article>
        </div>
    </body>

</html>
