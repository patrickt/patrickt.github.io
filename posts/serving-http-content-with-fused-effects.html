<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta name="author" content="Patrick Thomson" />
        <link rel="stylesheet" type="text/css" href="../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>
            adventures in uncertainty: Serving HTTP Content with Fused-Effects
        </title>
    </head>


    <body>
        <div id="header">
            <a href="../">home</a>
            <a href="../archive.html">archive</a>
            <a href="../about.html">about</a>
            <a href="../contact.html">contact</a>
        </div>
        <div id="content">
            <article>
                <h1>Serving HTTP Content with Fused-Effects</h1>
                
                  <h2>2019-11-22</h2>
                
                <section>
                    <p>In the Haskell community, 2019 was the year of effect systems. From <a href="https://github.com/hasura/eff"><code>eff</code></a> to <a href="http://hackage.haskell.org/package/polysemy"><code>polysemy</code></a> to <a href="http://hackage.haskell.org/package/capability"><code>capabilities</code></a> to <a href="http://hackage.haskell.org/package/fused-effects"><code>fused-effects</code></a>, we’ve seen a whole class of libraries providing an alternative to <a href="http://hackage.haskell.org/package/mtl"><code>mtl</code></a>, the historical <em>de facto</em> choice for expressing effects in Haskell. I <a href="https://www.youtube.com/watch?v=vfDazZfxlNs">spoke at Strange Loop</a> about the definition and history of effect systems, the tradeoffs associated with selecting an effect system, and why I think <code>fused-effects</code> is an excellent choice. The response from the Haskell community has been exciting: projects like the <a href="https://github.com/aurapm/aura">Aura package manager</a>, the <a href="https://github.com/owickstrom/komposition">Komposition video editor</a>, and the <a href="https://github.com/github/semantic"><code>semantic</code></a> analysis toolkit have adopted <code>fused-effects</code><span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">I’m personally quite pleased that this is the case, having been present at <code>fused-effects</code>’s inception, and having been lucky enough to contribute alongside <a href="https://twitter.com/rob_rix">Rob</a>’s incredible efforts.<br />
<br />
</span></span>, and the <a href="http://hackage.haskell.org/package/axel">Axel</a> programming language is built atop <code>polysemy</code>.</p>
<p>Yet the number one complaint that Rob and I have heard from prospective users is that there doesn’t exist an end-to-end tutorial demonstrating to those already familiar with <code>mtl</code> the process of building applications with <code>fused-effects</code>. This post exists to fill that particular need: I’ll show you how to use <code>fused-effects</code>’s APIs to build a minimal but aesthetically-pleasing syntax for handling HTTP requests and serving HTTP content.</p>
<p>This post will take an ad-hoc approach to the problem. While <code>fused-effects</code> often shines brightest when used in conjunction with user-defined, situationally-appropriate effect types, it’s profoundly useful for small, one-off tasks. The syntactic tools provided by <code>fused-effects</code> itself are often wholly adequate for taming the complexity associated with a complicated function signature or unwieldy API. For simplicity’s sake, we won’t bother with request routing, caching, or any of the features associated with apps built on actual web frameworks.</p>
<p>Let’s get started. This post is literate Haskell; you can find its source here. We’ll call this little web app <code>Quad</code>, in homage to <a href="https://en.wikipedia.org/wiki/86-DOS">another</a> quick-and-dirty software product of yesteryear.</p>
<div class="sourceCode" id="cb1" data-tangle="../src/Web/Quad.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE TypeApplications, OverloadedStrings #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">module</span> <span class="dt">Web.Quad</span> <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.Wai</span> <span class="kw">as</span> <span class="dt">Wai</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.HTTP.Types</span> <span class="kw">as</span> <span class="dt">HTTP</span></span></code></pre></div>
<p>We’ll use the <a href="http://hackage.haskell.org/package/wai"><code>wai</code></a> framework to abstract over the interface over whatever web server we end up using; like its Python cousin <a href="https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a> or Ruby’s <a href="https://github.com/rack/rack"><code>rack</code></a>, Wai is little more than a shared set of types and calling conventions for communicating with a web server. It defines <code class="sourceCode haskell"><span class="dt">Request</span></code> and <code class="sourceCode haskell"><span class="dt">Response</span></code> types; our DSL will consume <code class="sourceCode haskell"><span class="dt">Request</span></code>s and produce <code class="sourceCode haskell"><span class="dt">Response</span></code>s. The <a href="http://hackage.haskell.org/package/http-types"><code>http-types</code></a> package provides a shared vocabulary to describe request types (<code>GET</code>, <code>POST</code>, etc.) and response codes (<code>200 OK</code>, <code>404 Not Found</code>, etc.)</p>
<h1 id="desiderata">Desiderata</h1>
<p>The list of things that an app atop a web server <em>can</em> do is considerable. We don’t have the space, time, or inclination to write a full-fledged Rails clone here, so let’s err on the side of the minimal. The sparsest possible vocabulary associated with an HTTP request handler involves these items:</p>
<ol>
<li>immutable access to the current HTTP request;</li>
<li>mutable access to the current HTTP response;</li>
<li>an accumulated set of headers that will be returned alongside a response;</li>
<li>and a way to respond to the client with a stream of bytes.</li>
</ol>
<p>The process of building programs with <code>fused-effects</code> involves mapping desired program behavior to a set of one or more effects, then interpreting those effects into a result data type. Depending on your goals, you may be able to use the effects and monads that come with <code>fused-effects</code>, or you may have to write your own effects. As mentioned above, this post will use an ad-hoc approach, building this app’s capabilities atop the effects provided by <code>fused-effects</code>’s core.</p>
<p>Having identified these four requirements, we now need to know how to represent them in code. To do this, we need to consult <code>wai</code>’s most fundamental definition.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- from Network.Wai</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">type</span> <span class="dt">Application</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="ot">=</span>  <span class="dt">Request</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="ot">-&gt;</span> (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span></span></code></pre></div>
<p>This declaration defines an <code class="sourceCode haskell"><span class="dt">Application</span></code> type. Values of type <code class="sourceCode haskell"><span class="dt">Application</span></code> are functions that take two arguments. This first argument is an immutable <code class="sourceCode haskell"><span class="dt">Request</span></code>; the second is a function that takes a <code class="sourceCode haskell"><span class="dt">Request</span></code> and returns an opaque <code class="sourceCode haskell"><span class="dt">ResponseRecieved</span></code> type.</p>
<p>We access the properties of the current request through accessors provided by <code>Network.Wai</code>, and we yield a <code>ResponseReceived</code> by constructing a <code class="sourceCode haskell"><span class="dt">Response</span></code> datum and passing it to the provided function. This means that whatever effectful abstraction we choose, the result of interpreting an effectful action will be an <code>Application</code>—a function type that we pass into our chosen HTTP server. Our task now is to identify which effects we will use to pair a type provided by <code>wai</code> with its corresponding capability:</p>
<table>
<thead>
<tr class="header">
<th>Capability</th>
<th>Wai type</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Immutable requests</td>
<td><code>Wai.Request</code></td>
<td><code>Reader Wai.Request</code></td>
</tr>
<tr class="even">
<td>Mutable responses</td>
<td><code>HTTP.Status</code></td>
<td><code>State HTTP.Status</code></td>
</tr>
<tr class="odd">
<td>Accumulated headers</td>
<td><code>Wai.ResponseHeaders</code></td>
<td><code>Writer Wai.ResponseHeaders</code></td>
</tr>
<tr class="even">
<td>Streaming responses</td>
<td><code>Streaming.ByteString</code></td>
<td><code>Lift Streaming.ByteString</code></td>
</tr>
</tbody>
</table>
<p>These effects may be familiar to you. The <code>Reader</code> effect corresponds to <code>mtl</code>’s <code>MonadReader</code>, the <code>State</code> effect to <code>MonadState</code>, <code>Writer</code> to <code>MonadWriter</code>, and <code>Lift</code> to <code>MonadTrans</code>. (Don’t worry about <code>Streaming.ByteString</code> yet.) We’ll import these effects’ definition from <code>fused-effects</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">import</span> <span class="dt">Control.Effect.Reader</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">import</span> <span class="dt">Control.Effect.State</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">import</span> <span class="dt">Control.Effect.Writer</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">import</span> <span class="dt">Control.Effect.Lift</span></span></code></pre></div>
<p>Yet it’s not enough just to import these effects. One of the primary wins associated with <code>fused-effects</code> is that it separates the interfaces associated with an effect from the implementation of that effect. One effect can have multiple interpretations; depending on our needs, we could interpret a state effect with a strict state monad, or a lazy state monad, or a reader monad wrapping a mutable reference. We call these monads that interpret an effect a <em>carrier</em>. These carriers live under <code>fused-effects</code>’s <code>Control.Carrier</code> hierarchy. Let’s import the carriers we need: we’ll be using strict state and writer monads, since we don’t need the generality provided by lazy state, and the lazy writer monad shouldn’t exist in the first place.</p>
<div class="sourceCode" id="cb4" data-tangle="../src/Web/Quad.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">import</span> <span class="dt">Control.Carrier.Reader</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">import</span> <span class="dt">Control.Carrier.Strict.State</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">import</span> <span class="dt">Control.Carrier.Writer</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">import</span> <span class="dt">Control.Carrier.Lift</span></span></code></pre></div>
<p>As it happens, the above carrier modules reexport their corresponding effects, so the above imports from <code>Control.Effect</code> are not necessary: you only need O(n) imports, not O(2n). You’re welcome.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.Wai.Handler.Warp</span></span></code></pre></div>
<p>We’ll pull in the <a href="http://hackage.haskell.org/package/warp"><code>warp</code></a> web server to actually serve our requests.</p>
<div class="sourceCode" id="cb6" data-tangle="../src/Web/Quad.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Streaming</span> <span class="kw">as</span> <span class="dt">Streaming</span></span></code></pre></div>
<p>Finally, we’ll pull in the <a href="http://hackage.haskell.org/package/streaming-bytestring"><code>streaming-bytestring</code></a> library to provide a nice interface for streaming data over the wire. Haskell has many choices for streaming data; we could have used <a href="http://hackage.haskell.org/package/io-streams"><code>io-streams</code></a> or <a href="http://hackage.haskell.org/package/pipes-bytestring"><code>pipes-bytestring</code></a>, but <code>streaming-bytestring</code> is convenient in that its underlying type, the <code>ByteString</code> monad transformer, represents computations that involve streamed bytes. By using the <code>ByteString</code> monad as the base effect in our effect stack, we can use the <code>Lift</code> effect to abstract over the action of streaming bytes into the body of a <code>Response.</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">type</span> <span class="dt">ByteStream</span> <span class="ot">=</span> <span class="dt">Streaming.ByteString</span> <span class="dt">IO</span></span></code></pre></div>
<p>To disambiguate the <code>Lazy.ByteString</code> type from the <code>Streaming.ByteString</code> monad, we’ll define a type synonym for the <code>ByteString</code> monad over <code>IO</code>.</p>
<h1 id="a-simple-handler">A Simple Handler</h1>
<p>Let’s dive right in. We’ll use the effects we’ve imported to write a dead-simple web handler.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">helloWorld ::</span> ( <span class="dt">Has</span> (<span class="dt">Reader</span> <span class="dt">Wai.Request</span>) sig m</span>
<span id="cb8-2"><a href="#cb8-2"></a>              , <span class="dt">Has</span> (<span class="dt">State</span> <span class="dt">HTTP.Status</span>) sig m</span>
<span id="cb8-3"><a href="#cb8-3"></a>              , <span class="dt">Has</span> (<span class="dt">Writer</span> <span class="dt">Wai.ResponseHeaders</span>) sig m</span>
<span id="cb8-4"><a href="#cb8-4"></a>              , <span class="dt">Has</span> (<span class="dt">Lift</span> <span class="dt">ByteStream</span>) sig m</span>
<span id="cb8-5"><a href="#cb8-5"></a>              )</span>
<span id="cb8-6"><a href="#cb8-6"></a>           <span class="ot">=&gt;</span> m ()</span></code></pre></div>
<p>Declaring this signature establishes <code class="sourceCode haskell">helloWorld</code> as a monadic action <code>m</code> returning no interesting result (the unit type <code>()</code>). We declare the capabilities of this handler piecewise by using the <code class="sourceCode haskell"><span class="dt">Has</span></code> constraint: a <code class="sourceCode haskell"><span class="dt">Has</span> eff sig m</code> constraint declares that the monad <code>m</code> has access to the effect <code>eff</code> in the given signature <code>sig</code>. (We’ll touch more on what signatures mean in <code>fused-effects</code> later; you can ignore them for now). (Note that we don’t return a result here, even though <code>wai</code> expects us ultimately to return a <code class="sourceCode haskell"><span class="dt">ResponseReceived</span></code> datum, because we’ll build that datum when we interpret the <code class="sourceCode haskell">helloWorld</code> action into a concrete type.) Now that we have a signature for this action, we can define a minimally-interesting body for it.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>helloWorld <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>  req <span class="ot">&lt;-</span> ask <span class="op">@</span><span class="dt">Request</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  tell <span class="op">@</span><span class="dt">Wai.ResponseHeaders</span> [(HTTP.hContentType, <span class="st">&quot;text/plain&quot;</span>)]</span>
<span id="cb9-4"><a href="#cb9-4"></a>  sendM <span class="st">&quot;Hello, world!\n&quot;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>  sendM (<span class="st">&quot;You requested &quot;</span> <span class="op">&lt;&gt;</span> Streaming.fromStrict (Wai.rawQueryString reqd))</span>
<span id="cb9-6"><a href="#cb9-6"></a>  put <span class="op">@</span><span class="dt">HTTP.Status</span> HTTP.ok200</span></code></pre></div>
<p>This is a little involved, so let’s step through it slowly:</p>
<ul>
<li>The call to <code class="sourceCode haskell">ask</code> invokes the <code class="sourceCode haskell"><span class="dt">Reader</span></code> effect. Note that we provide it a <a href="https://blog.sumtypeofway.com/fluent-polymorphism-with-visible-type-applications/">visible type application</a>; unlike <code>mtl</code>, actions expressed with <code>fused-effects</code> can have multiple <code class="sourceCode haskell"><span class="dt">Reader</span></code> or <code class="sourceCode haskell"><span class="dt">State</span></code> constraints, and because of this we generally use the type application syntax to indicate to which type a call to <code class="sourceCode haskell">ask</code>, <code class="sourceCode haskell">gebt</code>, or <code class="sourceCode haskell">put</code> refers.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">Because we pass the yielded datum to the <code class="sourceCode haskell">rawQueryString</code> function, which takes a <code class="sourceCode haskell"><span class="dt">Wai.Request</span></code>, GHC is able to infer the type of this call to <code class="sourceCode haskell">ask</code> without the explicit type application; I’ve kept it in there both for pedagogy’s sake and out of personal preference.<br />
<br />
</span></span> This is very handy in that it lets us manipulate exactly what state and context types we need, without having to resort to the <a href="https://carlo-hamalainen.net/2015/07/20/classy-mtl/">“classy-lenses”</a> approach due to <code>mtl</code> imposing only one <code>MonadReader</code> and <code>MonadState</code> constraint per action.</li>
<li>Similarly, we call <code class="sourceCode haskell">tell</code> to invoke the <code class="sourceCode haskell"><span class="dt">Writer</span></code> effect, providing it with a list of header-value pairs. Again, we use a visible type application to indicate both to the compiler and reader what <code>Writer</code> constraint we want to invoke.</li>
<li>The call to <code class="sourceCode haskell">sendM</code> invokes the <code class="sourceCode haskell"><span class="dt">Lift</span></code> effect. Like the <code class="sourceCode haskell">lift</code> function provided by <code class="sourceCode haskell"><span class="dt">MonadTrans</span></code>, this function lifts actions in a context’s base monad (here <code>ByteStream</code>) into that context. Because <code>ByteStream</code> has an <code>IsString</code> instance, we can represent the action of sending the string <code>Hello, world!</code> down the pipe with the string literal <code class="sourceCode haskell"><span class="st">&quot;Hello, world!&quot;</span></code>. We could also use the <code>Streaming.string</code> helper function if we wished to eschew the <code>OverloadedStrings</code> extension.</li>
<li>Finally, we call <code class="sourceCode haskell">put</code> to hook into the <code>State</code> effect, setting the mutable <code>HTTP.Status</code> datum to return <code>200 OK</code>.</li>
</ul>
<p>This isn’t a hugely interesting HTTP handler, but it’s good enough for our purposes. Our next step is to interpret this effect.</p>
<h1 id="interpretation">Interpretation</h1>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb10-2"><a href="#cb10-2"></a>main <span class="ot">=</span> Warp.run <span class="dv">8080</span> (runApplication helloWorld)</span></code></pre></div>
<p>To actually serve a request, we need to call <code>warp</code>’s <code class="sourceCode haskell">run</code> function, which takes a port number and a <code class="sourceCode haskell"><span class="dt">Wai.Application</span></code> to run. This is not rocket science, but it does pose us a problem: we need to define a <code class="sourceCode haskell">runApplication</code> function if we want to actually compile this. At this point, <code>fused-effects</code>’s idioms start divering from those of <code>mtl</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">-- mtl style</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">newtype</span> <span class="dt">WebT</span> m a <span class="ot">=</span> <span class="dt">WebT</span> {<span class="ot"> unWebT ::</span> <span class="dt">WriterT</span> <span class="dt">Wai.ResponseHeaders</span> (<span class="dt">StateT</span> <span class="dt">HTTP.Status</span> (<span class="dt">Streaming.ByteString</span> m)) a }</span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadState</span> <span class="dt">HTTP.Status</span>, <span class="dt">MonadWriter</span> <span class="dt">Wai.ResponseHeaders</span>, <span class="dt">MonadTrans</span>)</span>
<span id="cb11-4"><a href="#cb11-4"></a></span></code></pre></div>
<p>In an <code>mtl</code> universe, we’d define our own monad transformer, and we’d use the <code>GeneralizedNewtypeDeriving</code> extension to conform to the various <code>MonadFoo</code> interfaces. We can build our <code>fused-effects</code> applications with this kind of concrete monad stack, and sometimes we may wish to do so, but for this case the particulars of our monad stack aren’t particularly interesting. In this case, we want to abstract over the particulars of what concrete monad stack we use. As such, we’ll use the <code>PartialTypeSignatures</code> extension to leave this type purposely abstract: by prefixing our monad type <code>m</code> with an underscore, GHC will infer from our interpretation functions what concrete type to use.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">runApplication ::</span> _m () <span class="ot">-&gt;</span> <span class="dt">Application</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>runApplication action req respond <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We’re going to use the functions provided by the imported <code>Control.Carrier</code> modules to interpret <code>action</code> into the types we need to build a <code>ResponseReceived</code> datum. These functions obey the naming convention established by the <code>transformers</code> package, though their parameter orders have been changed to make composition easier.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>result <span class="ot">&lt;-</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  ByteStream.toLazy</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="op">.</span> runM <span class="op">@</span><span class="dt">ByteStream</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="op">.</span> runReader <span class="op">@</span><span class="dt">Wai.Request</span> req</span>
<span id="cb13-5"><a href="#cb13-5"></a>  <span class="op">.</span> runState <span class="op">@</span><span class="dt">HTTP.Status</span> HTTP.status500</span>
<span id="cb13-6"><a href="#cb13-6"></a>  <span class="op">.</span> runWriter <span class="op">@</span><span class="dt">Wai.Response</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>  <span class="op">$</span> action</span></code></pre></div>
<p>This will be immediately familiar to people who, like me, have spent dozens and dozens of hours wrapping and unwrapping <code>mtl</code> transformer stacks. But there are some immediate differences. Note, for example, that we’ve specified the order of effects not with a data structure, as in the <code class="sourceCode haskell"><span class="dt">WebT</span></code> monad above, but with the calls to the <code>run</code> family of functions. Because the <code>.</code> operator works right-to-left, we start by discharging the <code class="sourceCode haskell"><span class="dt">Writer</span></code> effect from <code class="sourceCode haskell">action</code>: this uses the <code>Control.Carrier.Writer.Strict</code> carrier to peel one layer of effects off of <code>action</code>. That carrier preserves all the result of all aggregated <code class="sourceCode haskell"><span class="dt">Writer</span></code> actions (such as <code class="sourceCode haskell">tell</code> or <code class="sourceCode haskell">listen</code>) into a <code class="sourceCode haskell"><span class="dt">Wai.ResponseHeaders</span></code> datum returned in a tuple. Later, when we need to construct a <code class="sourceCode haskell"><span class="dt">Response</span></code>, we’ll deconstruct <code class="sourceCode haskell">result</code> and extract that datum.</p>
<p>After peeling off that <code class="sourceCode haskell"><span class="dt">Writer</span></code> effect, we then peel off a <code class="sourceCode haskell"><span class="dt">State</span></code> effect. We pass a type application for explicitness’s sake, along with an initial datum with which this state value will be initialized (in this case <code class="sourceCode haskell">status500</code>). We then peel off the <code class="sourceCode haskell"><span class="dt">Reader</span></code> effect, passing the provided request data to <code class="sourceCode haskell">runReader</code>. Finally, we discharge the <code class="sourceCode haskell"><span class="dt">Lift</span></code> effect with <code class="sourceCode haskell">runM</code>, yielding a <code class="sourceCode haskell"><span class="dt">ByteStream</span></code> value, which we then interpret into a lazy bytestring paired with the status and header information.</p>
<p>At this point, <code>result</code> is of type <code class="sourceCode haskell"><span class="dt">Of</span> <span class="dt">Lazy.ByteString</span> (<span class="dt">ResponseHeaders</span>, (<span class="dt">Status</span>, ()))</code>. The <code class="sourceCode haskell"><span class="dt">Of</span></code> type comes from <code>streaming-bytestring</code>, where it represents a left-strict pair; the nested tuples represent the data yielded at each effect discharge, terminating in the unit value. With a <code>case</code> statement and some helper functions, we can build a <code>Response</code> and pass it to <code>respond</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">let</span> (respBody <span class="op">:&lt;</span> (headers, (status, ()))) <span class="ot">=</span> result</span>
<span id="cb14-2"><a href="#cb14-2"></a>respond (Wai.responseLBS status headers respBody)</span></code></pre></div>
<h1 id="some-more-abstractions">Some More Abstractions</h1>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">type</span> <span class="dt">Web</span> sig m <span class="ot">=</span> ( <span class="dt">Has</span> (<span class="dt">Reader</span> <span class="dt">Wai.Request</span>) sig m</span>
<span id="cb15-2"><a href="#cb15-2"></a>                 , <span class="dt">Has</span> (<span class="dt">State</span> <span class="dt">HTTP.Status</span>) sig m</span>
<span id="cb15-3"><a href="#cb15-3"></a>                 , <span class="dt">Has</span> (<span class="dt">Writer</span> <span class="dt">HTTP.ResponseHeaders</span>) sig m</span>
<span id="cb15-4"><a href="#cb15-4"></a>                 , <span class="dt">Has</span> (<span class="dt">Lift</span> <span class="dt">ByteStream</span>) sig m</span>
<span id="cb15-5"><a href="#cb15-5"></a>                 )</span></code></pre></div>
<p>With the <code>ConstraintKinds</code> extension to GHC, we can give a single name to the set of effects required to express a Wai application.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">htmlHandler ::</span> <span class="dt">Web</span> sig m <span class="ot">=&gt;</span> m ()</span>
<span id="cb16-2"><a href="#cb16-2"></a>htmlHandler <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>  put <span class="op">@</span><span class="dt">HTTP.Status</span> HTTP.status200</span>
<span id="cb16-4"><a href="#cb16-4"></a>  sendM <span class="st">&quot;&lt;html&gt;&lt;h1&gt;Hello.&lt;/h1&gt;&lt;/html&gt;“</span></span></code></pre></div>
<p>This cleans up the type signatures of our handler functions considerably. We are not, however, locked into using <em>just</em> these effects.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">-- Assume we have some 'Config' data type providing a 'responseFromConfig' function.</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="ot">htmlHandler ::</span> (<span class="dt">Has</span> (<span class="dt">Reader</span> <span class="dt">Config</span>) sig m, <span class="dt">Web</span> sig m) <span class="ot">=&gt;</span> m ()</span>
<span id="cb17-3"><a href="#cb17-3"></a>htmlHandler <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>  cfg <span class="ot">&lt;-</span> ask <span class="op">@</span><span class="dt">Config</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>  put <span class="op">@</span><span class="dt">HTTP.Status</span> HTTP.status200</span>
<span id="cb17-6"><a href="#cb17-6"></a>  sendM (responseFromConfig cfg)</span></code></pre></div>
<p>We’re able to add a new <code>Reader</code> constraint to a handler, even though we already have a <code>Reader</code> constraint in the <code>Web</code> synonym, because <code>fused-effects</code> is just that versatile. (This would not be possible to do with the <code>WebT</code> monad transformer.)</p>
<p>At this point, we have enough code to run these actions. Let’s do so:</p>
<pre><code>$ curl localhost:8080/?query
Hello, world!
You requested: ?query
</code></pre>
<p>Is this an exciting web application? No. It provides very few features and no request routing at all. Furthermore, it’s an admittedly ad-hoc design. A better and more morally-upstanding design would define custom effects for the four capabilities of our web server. And indeed we will do that… next time.</p>
                </section>
            </article>
        </div>
    </body>

</html>
