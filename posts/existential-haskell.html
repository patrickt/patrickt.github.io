<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8" />
        <meta name="author" content="Patrick Thomson" />
        <link rel="stylesheet" type="text/css" href="../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>
            adventures in uncertainty: Existential Haskell
        </title>
    </head>


    <body>
        <div id="header">
            <a href="../">home</a>
            <a href="../archive.html">archive</a>
            <a href="../about.html">about</a>
            <a href="../contact.html">contact</a>
            <a href="../atom.xml">feed</a>
        </div>
        <div id="content">
            <article>
                <h1>Existential Haskell</h1>
                
                  <h2>2020-11-25</h2>
                
                <section>
                    <p>The majority of software engineering literature portrays object-oriented programming as distinct from, and often irreconcilable with, functional programming. This is, of course, a false dichotomy, as the techniques encouraged by functional programming are applicable in even the most object-oriented languages. Yet object-orientation, being perhaps history’s most popular software paradigm, has popularized its tenets, and occasionally we can see them show up even in programming languages like Haskell, a language about as antithetical to the object-oriented philosophy as possible.</p>
<p>In this piece, I’ll describe a common example of <a href="https://en.wikipedia.org/wiki/Information_hiding">information hiding</a> in ALGOL-style languages like Java, then express that in terms compatible with Haskell. We’ll then use this technique to port a <em>responder chain</em> to Haskell, demonstrating how Haskell supports dynamic function dispatch in the presence of hidden type information. I write this not because I expect to break any new ground—all the techniques I use here are long-documented in the literature, and Haskell veterans will probably find little new in this post<span><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle" /><span class="sidenote">Those familiar with the care and feeding of existential types may wish to skip to the penultimate section, which contains a couple useful data types that I haven’t yet seen in the wild.<br />
<br />
</span></span>—but because the existing resources are scattered, perhaps oddly so given how central dynamic dispatch is to most programming languages that aren’t Haskell, and because exploring the edge cases in the design illustrates the compromises inherent in language and library design.</p>
<h1 id="the-normal-way-to-do-things">the “normal” way to do things</h1>
<p>Most of the world’s statically-typed programming languages allow their users to write code resembling the following Java:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">public</span> <span class="dt">static</span> <span class="bu">Comparable</span> <span class="fu">someFn</span>() {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="kw">return</span> <span class="st">&quot;a concrete String value&quot;</span>;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Syntactically, this code is uncontroversial: it’s a function that returns a value. Its only interesting aspect lies in the function signature−even though the function body returns a value of type <code>String</code>, its return type is declared to be <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html"><code>Comparable</code></a>, which is not a concrete data type, but a Java <a href="https://en.wikipedia.org/wiki/Interface_(computing)">interface</a>. As such, we cannot treat the result of this function call as the <code>String</code> it actually is; we can only interact with it via the methods defined on the <code>Comparable</code> interface. This application of the <a href="https://en.wikipedia.org/wiki/Rule_of_least_power">rule of least power</a> is a useful one, even in a strongly-typed language like Haskell: sometimes we want to hide the implementation details of a function’s return type.</p>
<p>We can try to write the same thing in Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">someComparableValue ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>someComparableValue _ <span class="ot">=</span> <span class="st">&quot;a concrete string value&quot;</span></span></code></pre></div>
<p>Because this is not semantically-valid Haskell, we get the following error:</p>
<pre><code>&lt;interactive&gt;:3:27: error:
    • Couldn't match expected type ‘a’ with actual type ‘[Char]’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          someComparableValue :: forall a. Ord a =&gt; Int -&gt; a
</code></pre>
<p>Haskell’s typechecker looks at the body of this function and says “hey, man, you’re returning a concrete string value here, not ’any type that is <code>Ord</code>–erable.’” Though this is a valid notion in Java, it’s not valid in Haskell. Another perspective on this is that Java allows a value to have more than one type: we can treat a Java string literal as a value of type <code>java.lang.String</code>, or of type<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">even though <code>Comparable</code> is an interface, not a concrete type<br />
<br />
</span></span> <code>Comparable</code>, or of its superclass <code>java.lang.Object</code>. However, since Haskell doesn’t support inheritance, Haskell treats its values as having one, and only one, type. Working around this takes a judicious application of an existential type.</p>
<h1 id="quick-some-definitions">quick, some definitions</h1>
<p>In Haskell, an <em>existential</em> data type is one that is defined in terms not of a concrete type, but in terms of a quantified type variable, introduced on the right-hand side of the data declaration. This is, as is the case for so many Haskell concepts, not a particularly helpful definition in the abstract. It’s easier to show than to tell, so let’s take a look at one of the canonical examples of an existential type: a <code>Showable</code> type that wraps any type that implements the <code>Show</code> interface.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Showable</span> <span class="ot">=</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Showable</span> a</span></code></pre></div>
<p>There are several interesting things about this data type. Firstly, it uses the <code>forall</code> keyword to introduce the <code>a</code> type variable: given that we’re dealing with <em>exist</em>-ential types, it threw me for a loop that there wasn’t an <code>exists</code> keyword.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">Scala reserves a <code>forSome</code> keyword for this purpose, which I think reads a little more accurately in terms of the intent of introducing this type variable: using the phrase “for all” is a bit inapposite given that the <code>Showable</code> constructor is applied to single values at a time.<br />
<br />
</span></span> Considering the constructor of <code>Showable</code> is perhaps more enlightening:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t <span class="dt">Showable</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="dt">Showable</span><span class="ot"> ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Showable</span></span></code></pre></div>
<p>We can read this as “<code>Showable</code> is a constructor that takes, for all types <code>a</code> such that <code>a</code> implements <code>Show</code>, an <code>a</code> value, and returns a value of type <code>Showable</code>, the internal <code>a</code> value of which is no longer visible to the world once it’s been applied.”</p>
<p>Secondly, we can’t use a <code>newtype</code> to declare an existential. Attempting to write the following:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Showable</span> <span class="ot">=</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Showable</span> a</span></code></pre></div>
<p>results in an error message:</p>
<pre><code>• A newtype constructor cannot have a context in its type
  Showable :: forall a. Show a =&gt; a -&gt; Showable
• In the definition of data constructor ‘Showable’
  In the newtype declaration for ‘Showable’
</code></pre>
<p>When we consider typeclasses as <a href="https://blog.sumtypeofway.com/posts/fluent-polymorphism-type-applications.html">dictionaries</a>, this restriction makes more sense: in GHC Core, this <code>Show a</code> constraint will be represented as a hypothetical <code>ShowDict</code> data type containing implementations for the <code>show</code>, <code>showsPrec</code>, and <code>showList</code> functions. In this light, we can see that <code>Showable</code> takes <em>two</em> parameters, not one: an <code>a</code> value to wrap, as well as the <code>ShowDict</code> dictionary associated with that value’s type. Newtypes exist to wrap single values, and here we’re wrapping both a datum and its associated <code>Show</code> dictionary: as a result, here we need a <code>data</code> declaration, even though the associated <code>Showable</code> constructor takes only one value (in Haskell surface syntax). This is an understandable limitation, though it would be cool if existential values of this sort could opt into the <code>deriving</code> mechanism in the manner of newtypes.</p>
<p>A third interesting thing: we can’t write a function that unwraps this data type. What might seem like an intuitive type for the function is rejected:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">-- GHC will reject this.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">unwrapShowable ::</span> <span class="dt">Showable</span> <span class="ot">-&gt;</span> (<span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>unwrapShowable (<span class="dt">Showable</span> a) <span class="ot">=</span> a</span></code></pre></div>
<p>We can see this explained a little more closely if we use the record selector syntax.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Showable</span> <span class="ot">=</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Showable</span> {<span class="ot"> getShowable ::</span> a }</span></code></pre></div>
<p>Attempting to use <code>getShowable</code> as a function that extracts some arbitrary <code>Show</code>–inhabiting type produces a well-explained error messages:</p>
<pre><code>&lt;interactive&gt;:1:1: error:
    • Cannot use record selector ‘getShowable’ as a function due to escaped type variables
      Probable fix: use pattern-matching syntax instead
    • In the expression: getShowable
</code></pre>
<p>The mental model I use here is that applying a constructor of an existential type serves as a sort of <a href="https://en.wikipedia.org/wiki/Event_horizon">event horizon</a> for type information. In other languages we can assemble heterogenous lists natively; in Haskell, by contrast, we have to opt into it explicitly: applying the <code>Showable</code> constructor to a value swallows its type information. We can’t write a function, whether the hand-written <code>unwrapShowable</code> or descending from our <code>getShowable</code> record selector, that unwraps some arbitrary type out of an existential. All that is retained is the ability, given a proper <code>case</code> statement to unwrap the value within the existential, to <code>Show</code> the value contained therein: it cannot <em>escape</em> its scope, as the error message above explains<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle" /><span class="sidenote">We can, however, use the <code>getShowable</code> record selector to update the wrapped value present in a <code>Showable</code>.<br />
<br />
</span></span>.</p>
<p>We can, as I mentioned above, cross the event horizon with a <code>case</code> statement, binding the <code>Show</code>–conforming contents to a variable name:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">let</span> shown <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span> <span class="dt">Showable</span> val <span class="ot">-&gt;</span> <span class="fu">show</span> val</span></code></pre></div>
<p>Inside the right-hand-side of this <code>case</code> statement, we have a value <code>x</code> in scope. A quick inquiry with type holes reveals the type we expect:</p>
<pre><code>• Relevant bindings include
    x :: a (bound at &lt;interactive&gt;:28:15)
  Constraints include Show a (from &lt;interactive&gt;:28:11-15)
</code></pre>
<p>All we know about this value <code>x</code> is that we can call <code>Show</code> on it. Other than passing it to the basic combinators (<code>id</code> and <code>const</code>), that’s <em>all we can do</em> with this value. Any bit of type information has been lost, replaced instead with <em>capabilities</em>, via typeclasses. Again, when we consider typeclasses as dictionary parameters, we can visualize how this works on a core-calculus level: we discard type information, including only the relevant dictionaries provided by the context of the <code>forall</code>.</p>
<p>A fourth and final interesting thing about this type is that you can write it, using the <code>GADTs</code> GHC extension, without an explicit <code>forall</code> keyword:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Showable</span> <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="dt">Showable</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Showable</span></span></code></pre></div>
<p>This stems from the fact that GADTs allow us to introduce per-constructor type variables and associated constraints, even if the type variable is not visible externally. Another thing to note is that data declarations containing existential values don’t have to be limited to a single value: they can hold concrete values, or values expressed with more <code>forall</code>–introduced type variables.</p>
<h1 id="casting-around-wildly">casting around wildly</h1>
<p>Being able to hide implementation details of a function’s return type is all well and good, but many users are going to need to convert (or attempt to convert) from an existential type back into a concrete type. Java provides this functionality with the <code>instanceof</code> operator and its cast syntax:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="bu">Comparable</span> c = <span class="fu">someFn</span>();</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="kw">if</span> c <span class="kw">instanceof</span> <span class="bu">String</span> {</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Got a string: &quot;</span> + (<span class="bu">String</span>)c);</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>} <span class="kw">else</span> {</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Casting to a String here would raise a ClassCastException&quot;</span>);</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is a consequence of all Java objects descending from <code>java.lang.Object</code>, and the ability of the <code>instanceof</code> operator to query the type of an object at runtime. Though this style of programming isn’t hugely popular in Haskell, it’s not unheard of, and Haskell indeed supports it: this is where the <a href="https://google.com/search?hl=en&amp;q=data.typeable"><code>Typeable</code></a> typeclass comes in. It’s most prominently at work in <code>base</code>, under <code>Control.Exception:</code></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">class</span> (<span class="dt">Typeable</span> a, <span class="dt">Show</span> e) <span class="ot">=&gt;</span> <span class="dt">Exception</span> e</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">SomeException</span> <span class="ot">=</span> <span class="kw">forall</span> e <span class="op">.</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">SomeException</span> e</span></code></pre></div>
<p>This code begins with the declaration of a new typeclass, <code>Exception</code>, that inherits from both <code>Typeable</code> and <code>Show</code>. The fact that the <code>Exception</code> typeclass inherits from <code>Typeable</code> means that we can use <code>cast</code>, the fundamental <code>Typeable</code> primitive, to do safe casting to concrete values, accounting for the possibility of failure.</p>
<p>Let’s take an example, in the lowly (or perhaps mighty, depending on how you look at it) <code>IO</code> monad, of using Haskell’s dynamically-typed exception hierarchy:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">cautiouslyPrint ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>cautiouslyPrint go <span class="ot">=</span> Control.Exception.catch (go <span class="op">&gt;&gt;=</span> <span class="fu">print</span>) handler</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="ot">    handler ::</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    handler (<span class="dt">SomeException</span> e) <span class="ot">=</span> <span class="kw">case</span> cast e <span class="kw">of</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>      <span class="dt">Just</span> <span class="dt">DivideByZero</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;divide by zero&quot;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Some other exception: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> e)</span></code></pre></div>
<p>Here we use the <code>catch</code> function to evaluate the provided <code>go</code> argument, invoking <code>handler</code> should a runtime exception be thrown. We’re only handling one possible error type: <code>DivideByZero</code>, one of the constructors of <code>ArithException</code>. However, we are doing so via a checked cast, courtesy of the <code>cast</code> function, because we’re not recognizing <code>ArithException</code> values directly: <code>handler</code> will be invoked on <em>any</em> exception, because <code>SomeException</code>, to <code>catch</code>, means “this catch statement should handle any and all exceptions thrown by its body.” Looking at the type of <code>cast</code> can be illuminating:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">cast ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span></code></pre></div>
<p><code>cast</code>, perhaps unsurprisingly, is defined to return <code>Just</code> a value when the types <code>a</code> and <code>b</code> line up. This is done dynamically, at runtime, thanks to the Typeable class, which is a special typeclass indeed: it’s one of only two typeclasses that GHC <em>explicitly prohibits</em> any user-specified instances. Try it; you’ll get your hand slapped:</p>
<pre><code>&lt;interactive&gt;:4:10: error:
    • Class ‘Typeable’ does not support user-specified instances
    • In the instance declaration for ‘Typeable Foo’
</code></pre>
<p>GHC is right to prohibit this: because <code>Typeable</code> is concerned with the internal representation of Haskell types in memory, it’s GHC’s responsibility to implement it for you. And indeed it does: all types implement <code>Typeable</code>, for free. Note that <code>cast</code> takes all type information into account, not just structure: in practice, this means that you can’t cast a <code>Nothing</code> value of type <code>Maybe Int</code> to a <code>Nothing</code> value of type <code>Maybe Char</code>, even though the standalone <code>Nothing</code> identifier can be implicitly cast to a value of <code>Maybe Char</code>, or <code>Maybe Int</code>, or <code>Maybe String</code>.</p>
<h1 id="fluent-dynamic-dispatch">fluent dynamic dispatch</h1>
<p>Let’s drop back to our prior example:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">handler ::</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>handler (<span class="dt">SomeException</span> e) <span class="ot">=</span> <span class="kw">case</span> cast e <span class="kw">of</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  <span class="dt">Just</span> <span class="dt">DivideByZero</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;divide by zero&quot;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Some other exception: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> e)</span></code></pre></div>
<p>As I mentioned, we’re only handling one possible error case: though <code>handler</code> will be invoked for all exception types, our <code>cast</code> operation only handles <code>DivideByZero</code> exceptions (of type <code>ArithException</code>). We can add new <code>ArithException</code> cases without difficulty:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="dt">Just</span> <span class="dt">DivideByZero</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;divide by zero&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="dt">Just</span> <span class="dt">Underflow</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;floating point shenanigans&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Some other exception: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> e)</span></code></pre></div>
<p>However, the problem becomes thornier when we want to handle disjoint <code>Exception</code>-conformant types. A naïve encoding of the problem will not work, as in the following<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle" /><span class="sidenote">Note that this syntax <code>Just (e :: ArithException)</code>, in which we annotate a value with an indicated type without pattern matching on it, requires the <code>ScopedTypeVariables</code> extension to be enabled. <code>ScopedTypeVariables</code> should <em>always</em> be enabled: it does the right and obvious thing.<br />
<br />
</span></span>, where we try to handle <code>ArithExceptions</code> and <code>ArrayExceptions</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="dt">Just</span> (<span class="ot">arith ::</span> <span class="dt">ArithException</span>) <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;arithmetic: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> arith)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="dt">Just</span> (<span class="ot">array ::</span> <span class="dt">ArrayException</span>) <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;array: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> array)</span></code></pre></div>
<p>This will produce a compiler error, because all the values on the left-hand-sides of a <code>case</code> statement’s branches must have the same type! A corrected version might read:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>handler (<span class="dt">SomeException</span> e) <span class="ot">=</span> <span class="kw">case</span> cast e <span class="kw">of</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  <span class="dt">Just</span> (<span class="ot">arith ::</span> <span class="dt">ArithException</span>) <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;arith: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> arith)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> cast e <span class="kw">of</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    <span class="dt">Just</span> (<span class="ot">array ::</span> <span class="dt">ArrayException</span>) <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;array: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> array)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Some other exception: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> e)</span></code></pre></div>
<p>To work around the fact that the first <code>cast</code> expression limits its result type to values of type <code>ArithException</code>, we have to call <code>cast</code> again: this time, the <code>Typeable</code> value is pinned to <code>ArrayException</code>, which lets us handle successful casts in the <code>Just</code> clause and failure in the <code>Nothing</code> clause.</p>
<p>There is a grave issue with the above pattern: it’s clunky as hell with only two cases, and gets even clunkier as you add more possible types. A more modern approach is to use GHC’s <code>MultiwayIf</code>, in a manner that can be surprising for newcomers. <code>if</code> statements are usually concerned with boolean values, but this one won’t be: instead, we’re going to call <code>cast</code>, using the <a href="https://en.wikibooks.org/wiki/Haskell/Control_structures#if_and_guards_revisited">guard syntax</a> to discriminate between cases. By guarding (with <code>|</code>) on <code>Just</code> values returned from <code>cast</code>, we can have something akin to a polytypic <code>case</code> statement:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">if</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Just</span> (<span class="ot">arith ::</span> <span class="dt">ArithException</span>) <span class="ot">&lt;-</span> cast e <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;arith: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> arith)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Just</span> (<span class="ot">array ::</span> <span class="dt">ArrayException</span>) <span class="ot">&lt;-</span> cast e <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;array: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> array)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Something else: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> e)</span></code></pre></div>
<p>This is arguably a bastardization of the spirit of <code>MultiWayIf</code>, which is ostensibly about simplifying large systems of boolean equations. Here, the only <code>Bool</code> value involved is <code>otherwise</code>, defined by the Prelude to be <code>True</code>. Because <code>True</code> is always, well, <code>True</code>, its position as the last branch will mean that it is always matched, unless matched by a previous case (that is, a successful <code>Just</code> value). Yet the <code>otherwise</code> is readable in context, the code’s intent is clear, and its one flaw—the repeated work associated with the multiple calls to <code>cast</code>—can be remedied with a simple <code>let</code> binding:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">if</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Just</span> (<span class="ot">arith ::</span> <span class="dt">ArithException</span>) <span class="ot">&lt;-</span> cast e <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;arith: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> arith)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Just</span> (<span class="ot">array ::</span> <span class="dt">ArrayException</span>) <span class="ot">&lt;-</span> cast e <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;array: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> array)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Something else: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> e)</span></code></pre></div>
<p>Though this kind of runtime polymorphism isn’t enormously common in Haskell–we usually resolve polymorphism at compile-time—it’s not unheard of, and, as mentioned above, is provided as part of the <code>Control.Exception</code> interface to GHC’s hierarchy of exceptions. This Haskell design pattern—an existential data type that inherits from <code>Typeable</code>—is as close to dynamic dispatch as Haskell gets. Though it’s not common, neither is it invalid: sometimes what’s needed is an event horizon, that hides the concrete representation of a datum but provides, via polymorphism, the chance to reconstitute itself into a concrete type with <code>Typeable</code>.</p>
<h1 id="lets-build-a-responder-chain">let’s build a responder chain</h1>
<p>Essential to most GUI programming is the notion of what macOS and iOS call the <a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events">responder chain</a>. The responder chain is responsible for passing events—key presses, mouse clicks, device motions—through the hierarchy of a user interface. For example, shaking one’s device in iOS produces an undo event, if the user has a text field selected. The responder chain is responsible for passing shake events down the window hierarchy, eventually settling on the text field; were it not selected, the rest of the UI would have a chance to intercept and interpret this event.</p>
<p>Implementing a responder chain is fairly straightforward in an object-oriented view of the world: there is some superclass that all user interface elements extend, and this interface provides a lingua franca for events to be dynamically dispatched. It becomes somewhat more intricate, at least on the face of it, in a strongly-typed world sans subtyping. Indeed, this was <a href="https://inessential.com/2016/05/14/the_tension_of_swift">one of the qualms</a> expressed by the Objective-C community in response to the emergence of Swift. While Swift is <a href="http://roopc.net/posts/2016/swifty-responder-chain/">perfectly capable</a> of expressing a fluent, idiomatic responder chain, the lesson is more broadly applicable. Indeed, we can envision a UI framework that implemented this behavior in Haskell:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Response</span> a <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>  <span class="dt">Accept</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Response</span> a</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>  <span class="dt">Finish</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Response</span> a</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>  <span class="dt">Defer</span><span class="ot"> ::</span> <span class="dt">Response</span> a</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a><span class="kw">class</span> (<span class="dt">Typeable</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Responder</span> a <span class="kw">where</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a><span class="ot">  respond ::</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Response</span> a</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">SomeResponder</span> <span class="ot">=</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Responder</span> a <span class="ot">=&gt;</span> <span class="dt">SomeResponder</span> a</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Chain</span> <span class="ot">=</span> <span class="dt">Chain</span> [<span class="dt">SomeResponder</span>]</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a><span class="co">-- Dirt-simple imperative implementation with the ST monad.</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a><span class="co">-- An implementation with a fold could do this all purely</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true"></a><span class="co">-- but the accumulator is a little fiddly</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true"></a><span class="ot">propagate ::</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> <span class="dt">Chain</span> <span class="ot">-&gt;</span> <span class="dt">Chain</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true"></a>propagate evt (<span class="dt">Chain</span> c) <span class="ot">=</span> runST <span class="kw">do</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true"></a>  <span class="co">-- We need a signaling variable in case something in the chain</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true"></a>  <span class="co">-- wants to abort the traversal.</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true"></a>  abort <span class="ot">&lt;-</span> newSTRef <span class="dt">False</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true"></a>  <span class="co">-- Iterate through the responder chain...</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true"></a>  result <span class="ot">&lt;-</span> for c \(<span class="dt">SomeResponder</span> item) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true"></a>    <span class="co">-- attempting to apply the function at each item</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true"></a>    <span class="kw">let</span> given <span class="ot">=</span> respond evt item</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true"></a>    <span class="co">-- but first checking to see if we've aborted in prior iterations</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true"></a>    done <span class="ot">&lt;-</span> readSTRef abort</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true"></a>    <span class="co">-- shortcut for rewrapping and returning a SomeResponder</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true"></a>    <span class="kw">let</span> wrap <span class="ot">=</span> <span class="fu">pure</span> <span class="op">.</span> <span class="dt">SomeResponder</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true"></a>    <span class="kw">if</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true"></a>      <span class="co">-- A prior Finish result means we no-op</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true"></a>      <span class="op">|</span> done <span class="ot">-&gt;</span> wrap item</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true"></a>      <span class="co">-- Return a new value while writing to the signal variable.</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true"></a>      <span class="op">|</span> <span class="dt">Finish</span> a <span class="ot">&lt;-</span> given <span class="ot">-&gt;</span> writeSTRef abort <span class="dt">True</span> <span class="op">*&gt;</span> wrap a</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true"></a>      <span class="co">-- Just return the new value.</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true"></a>      <span class="op">|</span> <span class="dt">Accept</span> a <span class="ot">&lt;-</span> given <span class="ot">-&gt;</span> wrap a</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true"></a>      <span class="co">-- No match? Continue onward</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true"></a>      <span class="op">|</span> <span class="dt">Defer</span> <span class="ot">-&gt;</span> wrap item</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true"></a>  <span class="fu">pure</span> (<span class="dt">Chain</span> result)</span></code></pre></div>
<p>Similarly to the <code>Exception</code> class, we define a <code>Responder</code> typeclass that implements the interface common to all UI elements that can respond to some hypothetical <code>Event</code> type. This inherits both from <code>Show</code> and from <code>Typeable</code>, in order to admit the <code>cast</code> operation on the contents of a concrete <code>SomeResponder</code> wrapper. From this definition, we can describe a responder chain as a list of existentially-wrapped UI elements, the capabilities of which are described by the <code>Responder</code> class. This is profoundly imperative code, but that’s okay: sometimes imperative code is what’s needed, even in a functional</p>
<h1 id="one-polytypic-existential-to-rule-them-all">one polytypic existential to rule them all</h1>
<p>You, the reader, might at this point be turning up your nose at the idea of having to write a <code>forall</code>-based existential type for every concievable typeclass that you might need to wrap. This is indeed a valid observation. Luckily, GHC Haskell gives us sufficient tools to write a data type that is polymorphic not just in terms of a hidden value it wraps, but in terms of the typeclass it uses!</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Some</span> (<span class="ot">c ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>  <span class="dt">Some</span><span class="ot"> ::</span> c a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> c</span></code></pre></div>
<p>With the <code>TypeApplications</code> and <code>ConstraintKinds</code> extensions, we can specify that the type variable passed to <code>Some</code> is not of kind <code>Type</code>, or <code>Type -&gt; Type</code>; instead, it takes a <code>Type</code> and returns a <code>Constraint</code>. This means that we can pass in <code>Show</code>, <code>Eq</code>, <code>Ord</code>, or any other unary typeclass, using a type application:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">let</span> wrappedInt <span class="ot">=</span> <span class="dt">Some</span> <span class="op">@</span><span class="dt">Show</span> (<span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span></code></pre></div>
<p>This seems like a broadly applicable data type, but it’s not present in the standard library or any widely-used libraries (though the inimitable Rob Rix tells me that he’s defined it many times, at which I bear zero surprise, because Rob is a maestro).</p>
<p>We can extend this to types composed out of other types, like <code>[Int]</code> or <code>Vector String</code>: this <code>Some1</code> constructor is polymorphic in two type variables, both of which take arguments and return <code>Constraint</code> kinds.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Some1</span> c d <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>  <span class="dt">Some1</span> <span class="ot">::</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>    <span class="kw">forall</span> k</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>      (<span class="ot">c ::</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>      (<span class="ot">d ::</span> k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>      (<span class="ot">f ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>      (<span class="ot">a ::</span> k) <span class="op">.</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>    (c f, d a)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a>    <span class="ot">=&gt;</span> f a</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Some1</span> c d</span></code></pre></div>
<p>The built-in <code>~</code> syntax, included with the <code>GADTs</code> extension, provides us a method to establish that type variables must be equal: the present of an <code>a ~ Int</code> constraint ensures that the <code>a</code> type variable <em>must</em> unify with (read: be equal to) the <code>Int</code> type. By partially applying this constraint, we can speak of useful types with remarkable brevity, such as the following type representing “some <code>Functor</code> containing <code>Int</code> values”:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="ot">someFunctorOfInts ::</span> <span class="dt">Some1</span> <span class="dt">Functor</span> ((<span class="op">~</span>) <span class="dt">Int</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>someFunctorOfInts <span class="ot">=</span> <span class="dt">Some1</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span></code></pre></div>
<h1 id="i-dunno-draw-your-own-conclusions">I dunno, draw your own conclusions</h1>
<p>Haskell is a language where we like concrete, inferable types and type variables. Yet sometimes the Right Thing to do is to hide the details of heterogenous data types behind an existential wrapper—you can see this in action in <a href="https://github.com/github/semantic">Semantic</a>, where we hide the fact that different languages’ AST types are disjoint behind a <a href="https://github.com/github/semantic/blob/a44e3c40cc120b8efccb4908e3142482ea46577f/semantic/src/Parsing/Parser.hs#L52-L57"><code>SomeParser</code> wrapper</a>. And though existentials in Haskell are a little odd, at least when compared to standard data types, they’re nonetheless profoundly useful, both in the abstract and when dealing with the nitty-gritty of data manipulation.</p>
<p><em>Thanks to Ayman Nadeem, Rob Rix, and Peter Berger for reviewing drafts of this post.</em></p>
                </section>
            </article>
        </div>
    </body>

</html>
