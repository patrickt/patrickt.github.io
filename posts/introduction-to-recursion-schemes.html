<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta name="author" content="Patrick Thomson" />
        <link rel="stylesheet" type="text/css" href="../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>
            adventures in uncertainty: An Introduction to Recursion Schemes
        </title>
    </head>


    <body>
        <div id="header">
            <a href="../">home</a>
            <a href="../archive.html">archive</a>
            <a href="../about.html">about</a>
            <a href="../contact.html">contact</a>
        </div>
        <div id="content">
            <article>
                <h1>An Introduction to Recursion Schemes</h1>
                <section>
                    <p>In 1991, Erik Meijer, Maarten Fokkinga, and Ross Paterson published their now-classic paper <em><a href="https://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</a></em>. Though this paper isn’t widely known outside of the functional programming community, its contributions are astonishing: the authors use category theory to express a set of simple, composable combinators, called recursion schemes, that automate the process of traversing and recursing through nested data structures. Though recursion schemes predate Meijer et. al’s work, this paper brings the enormous abstractive power of category theory to bear on the subject of traversing data structures—it’s a magnificent example of how category-theoretical concepts can bring both rigor and simplicity to day-to-day programming tasks.</p>
<p>Because nested structures appear in almost every problem domain and programming environment, from databases to 3D graphics to filesystems, the act of iterating through these structures is common, so common that most programmers barely notice when they’re doing it. As such, generalizing the act of recursive traversals provides immediate real-world benefits: our new generalized traversal can replace a host of type-specific traversal functions. In addition, by decoupling <em>how</em> a function recurses over data from <em>what</em> the function actually does, we reduce cognitive overhead and can focus entirely on the core behavior of our recursive functions. No matter the structures in question—lists, directory hierarchies, control flow graphs, database records—recursion schemes bring us an orderly and predictable way to traverse them. In addition, recursion schemes aren’t a product of any one programming language or environment—you can express recursion schemes in any language with first-class functions. Clojure, for example, uses them to power its <a href="http://richhickey.github.io/clojure/clojure.walk-api.html"><code>clojure.walk</code></a> API for generically traversing s-expressions and maps.</p>
<p>Meijer et. al go so far as to condemn functional programming without recursion schemes as morally equivalent to imperative programming with <code>goto</code>. While comparisons to Djikstra’s <a href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf">infamous letter to the ACM</a> are often inane, the analogy is apt: just as using <code>while</code> and <code>for</code> loops rather than `goto` brings structure and harmony to imperative control flow, the use of recursion schemes over hand-written brings similar structure to recursive computations. This insight is so important that I’ll repeat it: <em>recursion schemes are just as essential to idiomatic functional programming as <code>for</code> and <code>while</code> are to idiomatic imperative programming</em>.</p>
<p>I’ve chosen to express the ideas in <em>Bananas, Lenses, Envelopes and Barbed Wire</em> in Haskell, though the paper was written years before Haskell came to prominence<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">Rather than tying <em>Bananas, Lenses, Envelopes and Barbed Wire</em> to any particular programming language, Meijer et. al used notation derived from <a href="http://en.wikipedia.org/wiki/Bird–Meertens_Formalism">Bird-Meertens formalism</a>, a calculus of program construction based on recursion schemes. Meijer’s Ph.D. thesis discussed compiler specifications using this notation, which was also known as Squiggol, after its ‘squiggly’ notation. Though this notation is well-specified, its syntactic constructions, featuring elements such as “banana brackets” and “concave lenses”, is somewhat abstruse.<br />
<br />
</span></span>. If you don’t know Haskell very well, <strong>don’t panic</strong>: you don’t need to be a Haskell whiz to understand the ideas presented here. I assume only a basic familiarity with <a href="http://cheatsheet.codeslower.com/CheatSheet.pdf">Haskell syntax</a> and the use of <a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses">algebraic data types</a>. I’m going to rely on a few idioms to better illustrate the concepts underlying recursion schemes—when I do, I will explain what happens behind the scenes. If you’re wholly unfamiliar with Haskell, you may want to dip into the first few chapters of <a href="http://haskellbook.com/">Haskell Programming from First Principles</a>.</p>
<p>I’ll start with the simplest way to represent a well-typed syntax tree, then show how that simplicity makes it difficult to write a function that generically traverses and modifies trees. I’ll then redefine our syntax tree so as to take advantage of existing Haskell idioms and the expressive power of parameterized data types. Finally, I’ll show how recursion schemes emerge naturally when we express step-by-step descriptions of recursion patterns with common Haskell idioms.</p>
<h1 id="syntax-trees-and-recursion">Syntax Trees and Recursion</h1>
<p>Let’s take a look at the simplest way to represent a syntax tree in Haskell: an ordinary algebraic datatype.</p>
<div class="sourceCode" id="cb1" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Lit</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="ot">=</span> <span class="dt">StrLit</span> <span class="dt">String</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="op">|</span> <span class="dt">IntLit</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="op">|</span> <span class="dt">Ident</span> <span class="dt">String</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="ot">=</span> <span class="dt">Index</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>  <span class="op">|</span> <span class="dt">Call</span> <span class="dt">Expr</span> [<span class="dt">Expr</span>]</span>
<span id="cb1-10"><a href="#cb1-10"></a>  <span class="op">|</span> <span class="dt">Unary</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>  <span class="op">|</span> <span class="dt">Binary</span> <span class="dt">Expr</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>  <span class="op">|</span> <span class="dt">Paren</span> <span class="dt">Expr</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>  <span class="op">|</span> <span class="dt">Literal</span> <span class="dt">Lit</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="kw">data</span> <span class="dt">Stmt</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>  <span class="ot">=</span> <span class="dt">Break</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>  <span class="op">|</span> <span class="dt">Continue</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>  <span class="op">|</span> <span class="dt">Empty</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>  <span class="op">|</span> <span class="dt">IfElse</span> <span class="dt">Expr</span> [<span class="dt">Stmt</span>] [<span class="dt">Stmt</span>]</span>
<span id="cb1-21"><a href="#cb1-21"></a>  <span class="op">|</span> <span class="dt">Return</span> (<span class="dt">Maybe</span> <span class="dt">Expr</span>)</span>
<span id="cb1-22"><a href="#cb1-22"></a>  <span class="op">|</span> <span class="dt">While</span> <span class="dt">Expr</span> [<span class="dt">Stmt</span>]</span>
<span id="cb1-23"><a href="#cb1-23"></a>  <span class="op">|</span> <span class="dt">Expression</span> <span class="dt">Expr</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>This is a perfectly adequate syntax tree: it’s simple, straightforward, and works nicely with parsing libraries such as <a href="http://hackage.haskell.org/package/attoparsec">attoparsec</a> or <a href="http://tanakh.github.io/Peggy/">Peggy</a>. Yet writing a function that operates on a <code>Expr</code> node and all its subexpressions is a tedious exercise indeed: here’s an example that flattens an <code>Expr</code>, recursively removing all <code>Paren</code> nodes:</p>
<div class="sourceCode" id="cb2" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- this would turn the expression</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">--    (((anArray[(10)])))</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">-- into</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">--    anArray[10]</span></span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ot">flatten ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">-- base case: do nothing to literals</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>flatten (<span class="dt">Literal</span> i) <span class="ot">=</span> <span class="dt">Literal</span> i</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co">-- this is the important case: we shed the Paren constructor and just</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">-- apply `flatten` to its contents</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>flatten (<span class="dt">Paren</span> e) <span class="ot">=</span> flatten e</span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co">-- all the other cases preserve their constructors and just apply</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="co">-- the flatten function to their children that are of type `Expr`.</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>flatten (<span class="dt">Index</span> e i)     <span class="ot">=</span> <span class="dt">Index</span> (flatten e) (flatten i)</span>
<span id="cb2-17"><a href="#cb2-17"></a>flatten (<span class="dt">Call</span> e args)   <span class="ot">=</span> <span class="dt">Call</span> (flatten e) (<span class="fu">map</span> flatten args)</span>
<span id="cb2-18"><a href="#cb2-18"></a>flatten (<span class="dt">Unary</span> op arg)  <span class="ot">=</span> <span class="dt">Unary</span> op (flatten arg)</span>
<span id="cb2-19"><a href="#cb2-19"></a>flatten (<span class="dt">Binary</span> l op r) <span class="ot">=</span> <span class="dt">Binary</span> (flatten l) op (flatten r)</span></code></pre></div>
<p>This isn’t good code. It’s clumsy. Four out of this function’s six lines are dedicated to the simple yet tedious task of ensuring that <code>flatten</code> propery recurses into its argument’s subexpressions—not only is this boring to write, but any future changes (such as added constructors or fields) to <code>Expr</code> will force us to rewrite it. (I’ll refer to recursion written in this style as <em>explicit recursion</em>, in contrast with the implicit recursion provided by recursion schemes.) In addition, it’s extremely easy to make mistakes in this definition—the syntatic noise that the primitive recursion introduces renders it hard to spot a missing recursive invocation of <code>flatten</code>, yet even one such omission introduces a critical bug.</p>
<p>We can, however, bring some sanity to this madness by writing a function <code>apply</code> that, given a function <code>f</code> operating on <code>Expr</code> values, applies <code>f</code> to each subexpression of a given <code>Expr</code>:</p>
<div class="sourceCode" id="cb3" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">applyExpr ::</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">-- base case: applyExpr is the identity function on constants</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>applyExpr f (<span class="dt">Literal</span> i) <span class="ot">=</span> <span class="dt">Literal</span> i</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">-- recursive cases: apply f to each subexpression</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>applyExpr f (<span class="dt">Paren</span> p) <span class="ot">=</span> <span class="dt">Paren</span> (f p)</span>
<span id="cb3-7"><a href="#cb3-7"></a>applyExpr f (<span class="dt">Index</span> e i) <span class="ot">=</span> <span class="dt">Index</span> (f e) (f i)</span>
<span id="cb3-8"><a href="#cb3-8"></a>applyExpr f (<span class="dt">Call</span> e args) <span class="ot">=</span> <span class="dt">Call</span> (f e) (<span class="fu">map</span> f args)</span>
<span id="cb3-9"><a href="#cb3-9"></a>applyExpr f (<span class="dt">Unary</span> op arg) <span class="ot">=</span> <span class="dt">Unary</span> op (f arg)</span>
<span id="cb3-10"><a href="#cb3-10"></a>applyExpr f (<span class="dt">Binary</span> l op r) <span class="ot">=</span> <span class="dt">Binary</span> (f l) op (f r)</span></code></pre></div>
<p>This function decouples the definition of a recursive function from its recursive application. with it, we can reduce our six-line definition of flatten to two lines. In the body of <code>flatten</code>, we need only specify that <code>Paren</code> nodes be treated differently than other nodes, relying on the <code>applyExpr</code> function to take care of recursion for us:</p>
<div class="sourceCode" id="cb4" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">flatten' ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>flatten' (<span class="dt">Paren</span> e) <span class="ot">=</span> flatten e</span>
<span id="cb4-3"><a href="#cb4-3"></a>flatten' x <span class="ot">=</span> applyExpr flatten x</span></code></pre></div>
<p>This function just got far, far easier to write and maintain. The <code>apply</code> function is now responsible for both the base case and the simple recursive case of flattening an expression: all we have to do is define the interesting case, i.e. its handling of <code>Paren</code> nodes. Awesome.</p>
<p>But let’s not get ahead of ourselves. We haven’t really prevented any boilerplate or eliminated room for bugs here: <code>applyExpr</code> just contains and isolates the boilerplate, and we’d need to write a new <code>apply</code> function for each and every new type we define. A sufficiently smart compiler could write them for us. And GHC, being a very smart compiler, can. First, though, we’ll have to make this <code>Expr</code> data type a little bit more general.</p>
<h1 id="parameterizing-our-types">Parameterizing Our Types</h1>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">data</span> <span class="dt">ExprF</span> a</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="ot">=</span> <span class="dt">Index</span> a a</span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="op">|</span> <span class="dt">Call</span> a [a]</span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="op">|</span> <span class="dt">Unary</span> <span class="dt">String</span> a</span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="op">|</span> <span class="dt">Binary</span> a <span class="dt">String</span> a</span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span class="op">|</span> <span class="dt">Paren</span> a</span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="op">|</span> <span class="dt">Literal</span> <span class="dt">Lit</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>This new definition of an expression differs from its predecessor in that we’ve added a type variable <code>a</code> and replaced all recursive occurrences of the <code>Expr</code> type with it. (By convention, we append the suffix <code>-F</code> to the type name and constructors of expressions in this formulation; the reason for this will become clear in a moment. Put another way, we have <em>parameterized</em> this type in terms of its subexpressions. As such, we have to change our definition of <code>applyExpr</code>: the function we apply to each subexpression can no longer be of type <code>Expr -&gt; Expr</code>, but must become <code>a -&gt; a</code>: indeed, we can make it <code>a -&gt; b</code>, letting the function change the type of an <code>Expr</code>’s subexpressions if necessary.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">apply ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ExprF</span> a <span class="ot">-&gt;</span> <span class="dt">ExprF</span> b</span></code></pre></div>
<p>The sharp-eyed among you will notice how similar this function is to the built-in <code>map</code> function over lists:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- `map` takes a function (a -&gt; b) and makes it operate on lists containing 'a's</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p>This is not a coincidence: in fact, the <code>apply</code> function is exactly analogous to <code>map</code> for lists—you can think about both functions as mapping or promoting a function <code>f</code> so as to operate on a larger datatype, whether that’s an <code>Expr</code> type or a list (<code>[]</code>) type. This pattern of mapping is so common that its generalized version is a central Haskell concept: the typeclass <code>Functor</code> represents all the types that provide a <code>map</code>-like function, called <code>fmap</code><span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">You may be curious as to why Haskell provides both <code>map</code> and <code>fmap</code> functions in its Prelude, considering that <code>map</code> is just a version of <code>fmap</code> that can only operate on lists. This has indeed been a bone of contention within the Haskell community. As Brent Yorgey, author of the essential <a href="http://www.haskell.org/haskellwiki/Typeclassopedia#Instances">Typeclassopedia</a>, put it: “the usual argument is that someone just learning Haskell, when using <code>map</code> incorrectly, would much rather see an error about lists than about Functors.”<br />
<br />
</span></span>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">  fmap ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>Countless datatypes—lists, trees, optional (<code>Maybe</code>) values, IO actions, even functions themselves—implement the <code>Functor</code> typeclass. Indeed, it’s so common, and implementing <code>fmap</code> is usually so straightforward, that GHC provides a built-in mechanism to write the definition of <code>fmap</code> for you: with GHC’s <code>DeriveFunctor</code> extension, we can just add <code>Functor</code> to the list of classes our <code>Expr</code> declaration derives, alongside <code>Show</code> and <code>Eq</code>:</p>
<div class="sourceCode" id="cb9" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">data</span> <span class="dt">ExprF</span> a</span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="ot">=</span> <span class="dt">IndexF</span> a a</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="op">|</span> <span class="dt">CallF</span> [a]</span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="op">|</span> <span class="dt">UnaryF</span> <span class="dt">String</span> a</span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="op">|</span> <span class="dt">BinaryF</span> a <span class="dt">String</span> a</span>
<span id="cb9-6"><a href="#cb9-6"></a>  <span class="op">|</span> <span class="dt">ParenF</span> a</span>
<span id="cb9-7"><a href="#cb9-7"></a>  <span class="op">|</span> <span class="dt">LiteralF</span> <span class="dt">Lit</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>) <span class="co">-- fmap for free</span></span></code></pre></div>
<p>In addition, you can derive instances of the <code>Foldable</code> and <code>Traversable</code> typeclasses, which provide dozens of useful functions to access and iterate through an <code>Expr</code>’s subexpressions—in essence, <code>Expr</code> now comes with batteries included. Parameterizing <code>Expr</code> and deriving <code>Functor</code>, <code>Foldable</code>, and <code>Traversable</code> provides us with an embarrassment of helper functions—but this parameterized version of <code>Expr</code> isn’t quite the same as our previous defintion!</p>
<p>Our first formulation of <code>Expr</code>, since its recursive subfields were of type <code>Expr</code>, could represent arbitrarily-nested <code>Expr</code> values, but this new one can’t—it seems like we always have to insert <code>Lit</code>—to establish the maximum possible depth of a tree of <code>Expr</code> values:</p>
<ul>
<li><code>ExprF Lit</code> represents an expression with no subexpressions</li>
<li><code>ExprF (ExprF Lit)</code> represents expressions with at most one more layer of subexpressions.</li>
<li><code>ExprF (ExprF (Expr Lit))</code> represents two-level expressions, and so on, and so forth.</li>
</ul>
<p>In order for the parameterized definition of <code>Expr</code> to be equal to our original formulation, we have to assume that there exists a type such that, when substituted for <code>a</code> in the definition of <code>Expr a</code>, yields an expression with arbitrarily-nested <code>Expr</code> subexpressions.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">type</span> <span class="dt">NestedExpr</span> <span class="ot">=</span> <span class="dt">ExprF</span> (<span class="dt">ExprF</span> (<span class="dt">ExprF</span> (<span class="dt">ExprF</span> …)))</span></code></pre></div>
<p>But in order for our assumption about the type variable <code>a</code> to hold true, we need some sort of trick that allows us to represent, in a finite manner, a representation of the type of arbitrarily-nested <code>Expr</code> values.</p>
<h1 id="fixed-points">Fixed Points</h1>
<p>Consider the Y-combinator. Given a function f that takes one argument, <code>y(f)</code> represents the result of repeatedly applying <code>f</code> to itself:</p>
<pre><code>y f = f (f (f (f ...)))
</code></pre>
<p>The sharp-eyed will have noticed that the expansion of <code>y(f)</code> is very similar to our <code>NestedExpr</code> type above. If we have a Y-combinator embedded entirely <em>in the type system</em>, we can describe the repeated application of <code>Expr</code> to itself, in a manner identical to how the value-level Y-combinator operates on functions, and in turn we can describe an <code>Expr a</code> where <code>a</code> represents an infinite stream of nested <code>Expr</code> values.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">type</span> <span class="dt">Y</span> t <span class="ot">=</span> t (t (t (t (t <span class="op">...</span>))))</span></code></pre></div>
<p>This general concept<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle" /><span class="sidenote">A complete discussion of the beauty and notability of fixed-point combinators is beyond the scope of this article: for such explorations, please refer to Raymond Smullyan’s wonderful <a href="http://www.amazon.com/To-Mock-Mockingbird-Other-Puzzles/dp/0192801422"><em>To Mock a Mockingbird</em></a> or Reginald Braithwaite’s <a href="https://leanpub.com/combinators">Kestrels, Quirky Birds, and Hopeless Egocentricity</a>.<br />
<br />
</span></span> is known as ‘fixed-point’: we say that <code>y(f)</code> is the fixed point (or fixpoint) of the <code>f</code> function, and that <code>Y Expr</code> is the <em>fixed point of the <code>Expr</code> functor</em>. And here’s the kicker—we can build a Y-combinator that works <em>in the type system</em> too, and that’s how we will express the self-similar nature of an <code>Expr</code>’s subexpressions.</p>
<p>We need a data type <code>Y</code> that, when given another type <code>f</code>, wraps an <code>f</code> whose children are of type <code>(Y f)</code>. Let’s call it <code>Term</code>, and let’s call its constructor <code>In</code>, representing the fact that we are stuffing one level of recursion into a fixed form. In addition, we’ll define an <code>out</code> function that unwraps a <code>Term</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">data</span> <span class="dt">Term</span> f <span class="ot">=</span> <span class="dt">In</span> (f (<span class="dt">Term</span> f))</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="ot">out ::</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> f (<span class="dt">Term</span> f)</span>
<span id="cb13-4"><a href="#cb13-4"></a>out (<span class="dt">In</span> t) <span class="ot">=</span> t</span></code></pre></div>
<p>It’s illuminating to substitute <code>Expr</code> in for the type variable <code>f</code> in this equation, in order to see what it looks like to construct and deconstruct the fixed-point of an <code>Expr</code> value. Using GHC’s <code>TypeApplications</code> extension to set the value <code>f</code> equal to <code>ExprF</code>, let’s ask GHCi the type signature of <code>In</code> over <code>ExprF</code> values.</p>
<div class="sourceCode" id="cb14" data-results="output" data-exports="both"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="op">:</span>t <span class="dt">In</span> <span class="op">@</span><span class="dt">ExprF</span><span class="ot"> ::</span> <span class="dt">ExprF</span> (<span class="dt">Term</span> <span class="dt">ExprF</span>) <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">ExprF</span></span></code></pre></div>
<pre class="example"><code>In @ExprF :: ExprF (Term ExprF) -&gt; Term ExprF
</code></pre>
<p>This tells us that in order to end up with a <code>Term ExprF</code> we have to pass an <code>ExprF</code> that, if it has children, contains further values of type <code>Term ExprF</code>. We apply this <code>In</code> constructor at each level of a nested <code>ExprF</code>. This allows us arbitrarily-nested types, while still permitting the vastly-convenient <code>Functor</code> instance and its attendant <code>fmap</code>.</p>
<p>The type <code>Term ExprF</code> will show up often, since it is the type equivalent to our old definition of <code>Expr</code>. Let’s declare a type synonym for this.</p>
<div class="sourceCode" id="cb16" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">type</span> <span class="dt">Expr'</span> <span class="ot">=</span> <span class="dt">Term</span> <span class="dt">ExprF</span></span></code></pre></div>
<p>A more idiomatic way to declare <code>Term</code> is to use a record field rather than declaring an unwrapper function, and to make this declaration a <code>newtype</code>, which allows GHC to optimize out construction and deconstruction of <code>Term</code> values with <code>In</code> and <code>out</code>.</p>
<div class="sourceCode" id="cb17" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">newtype</span> <span class="dt">Term</span> f <span class="ot">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> f (<span class="dt">Term</span> f) }</span></code></pre></div>
<p>From these definitions, we can see that, given a <code>Term Expr</code>, we can use the <code>out</code> function to convert it to an <code>Expr</code> the subexpressions of which are, in turn <code>Term Expr</code> values. That means that we can unwrap a <code>Term Expr</code> into an <em>arbitrarily-nested</em> <code>Expr</code> through successive applications of <code>out</code>: our <code>Term Expr</code> can expand into an <code>Expr (Term Expr)</code>, which can expand into an <code>Expr (Expr (Term Expr))</code>, and so on and so forth. This style of defining recursive types using fixed-points of functors is an example of <em>codata</em>. A full discussion of the theory behind codata (and the many different forms that codata can take) is, unfortunately, beyond the scope of this article; I recommend <a href="https://www.tac-tics.net/blog/data-vs-codata">this</a> excellent introduction.</p>
<h1 id="generic-traversals">Generic Traversals</h1>
<p>At this point, we’re well grounded in defining our data types with fixed-points of functors. Let’s do something awesome with them.</p>
<p>Consider the notion of the bottom-up traversal: specifically, the following algorithm for traversing the fixed-point of a functor:</p>
<ol>
<li>Unpack the term so as to access its children.</li>
<li>Recursively traverse each child of the unpacked term with ƒ.</li>
<li>Repack the term.</li>
<li>Apply ƒ to it.</li>
</ol>
<p>We have the tools to express each step of this procedure—let’s call it <code>bottomUp</code>.</p>
<div class="sourceCode" id="cb18" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">bottomUp ::</span> <span class="dt">Functor</span> a <span class="ot">=&gt;</span> (<span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb18-2"><a href="#cb18-2"></a>bottomUp fn <span class="ot">=</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>  out                    <span class="co">-- 1) unpack</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>  <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (bottomUp fn) <span class="co">-- 2) recurse</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>  <span class="op">&gt;&gt;&gt;</span> <span class="dt">In</span>                 <span class="co">-- 3) repack</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>  <span class="op">&gt;&gt;&gt;</span> fn                 <span class="co">-- 4) apply</span></span></code></pre></div>
<p>And there it is, our first recursion scheme. In writing <code>bottomUp</code> we have developed a type-safe <em>and</em> type-generic combinator for recursively transforming <em>any</em> Functor: whether it’s our <code>Expr</code> type from earlier, a list, a rose tree, or anything else. This is, frankly, kind of amazing. As such, let’s rewrite our original <code>flatten</code> function so that it operates on <code>Term</code> values that wrap arbitrarily-nested <code>Expr</code> values:</p>
<div class="sourceCode" id="cb19" data-tangle="../src/Part1.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">flattenTerm ::</span> <span class="dt">Expr'</span> <span class="ot">-&gt;</span> <span class="dt">Expr'</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>flattenTerm (<span class="dt">In</span> (<span class="dt">ParenF</span> e)) <span class="ot">=</span> e  <span class="co">-- remove all Parens</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>flattenTerm other <span class="ot">=</span> other       <span class="co">-- do nothing otherwise</span></span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="ot">flatten'' ::</span> <span class="dt">Expr'</span> <span class="ot">-&gt;</span> <span class="dt">Expr'</span></span>
<span id="cb19-6"><a href="#cb19-6"></a>flatten'' <span class="ot">=</span> bottomUp flattenTerm</span></code></pre></div>
<p>Given a function <code>fn</code> mapping from <code>Term</code> to <code>Term</code>, we’ll unpack the <code>Term</code> with the <code>out</code> function, recursively traverse each child of the unpacked term with <code>fmap (bottomUp fn)</code>, repack the term with the <code>In</code> constructor, and then simply apply <code>fn</code> to the result. The <code>fmap bottomUp</code> call does all the heavy lifting in this function: it captures the act of recursing into each child (if any) of a given functor.</p>
<p>Rather than naming both the <code>fn</code> function parameter and the <code>Term</code> parameter, I’m going to define <code>bottomUp</code> using combinators to join these four invocations—<code>out</code>, <code>fmap bottomUp</code>, <code>In</code>, and <code>fn</code>. Namely, I’m going to use the <code>&gt;&gt;&gt;</code> operator, defined in <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Arrow.html"><code>Control.Arrow</code></a>, for left-to-right function composition, <code>f &gt;&gt;&gt; g x</code> is equal to <code>g(f(x))</code>. Though this style is a bit unconventional—the right-to-left function composition operator, <code>.</code>, is more common—I’ve chosen to do this because it’s a useful visual indicator of the order in which functions are invoked. (This order will become important later.)</p>
<p>Though our previous definition of <code>flatten</code> that used <code>apply</code> to represent its recursion was concise, this is even more elegant: our <code>bottomUp</code> recusion scheme lets us factor out the recursive parts of this definition entirely. We can focus on the relevant behavior of the flattening function—namely, that it removes all <code>Paren</code> nodes—and define it in two simple clauses. In addition, recursively invoking this function with <code>bottomUp flattenTerm</code> is clearer than our prior definitions in that we have made the bottom-up nature of this traversal explicit. This is really a remarkable departure from our previous definition of <code>flatten</code>—it’s hard to imagine how it could be made shorter.</p>
<p>But let’s not rest on our laurels. Let’s consider the steps involved with writing a top-down traversal of a <code>Term</code>, the obvious analogue to our bottom-up traversal:</p>
<p>To traverse a Term top-down with a function ƒ, we:</p>
<ol>
<li>Apply ƒ to the term.</li>
<li>Unpack the term so as to access its children.</li>
<li>Recursively traverse each child of the term with ƒ.</li>
<li>Repack the term.</li>
</ol>
<p>These instructions are elegantly symmetrical with the ones for our bottom-up traversal—if you read the instructions in reverse and replace occurrences of “unpack” and “repack”, they are identical. And here’s the kicker: our code can capture this. We can express this notion of “reading in reverse” by replacing occurrences of the left-to-right operator <code>&gt;&gt;&gt;</code> with <code>&lt;&lt;&lt;</code>, the right-to-left operator<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle" /><span class="sidenote">This function is provided by the Haskell prelude with the <code>.</code> operator.<br />
<br />
</span></span>, and we swap “unpack” and “repack” with <code>out</code> and <code>In</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>topDown,<span class="ot"> bottomUp ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Term</span> f <span class="ot">-&gt;</span> <span class="dt">Term</span> f) <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> <span class="dt">Term</span> f</span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a>topDown f  <span class="ot">=</span> <span class="dt">In</span> <span class="op">&lt;&lt;&lt;</span> <span class="fu">fmap</span> (topDown f) <span class="op">&lt;&lt;&lt;</span> out <span class="op">&lt;&lt;&lt;</span> f</span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a>bottomUp f <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (bottomUp f) <span class="op">&gt;&gt;&gt;</span> <span class="dt">In</span> <span class="op">&gt;&gt;&gt;</span> f</span></code></pre></div>
<p>The fact that we can express the duality between top-down and bottom-up traversals merely by “reversing the arrows” that determine our code’s flow, all the while retaining generality and type safety, is nothing short of amazing. That these definitions emerged naturally out of fixed-points and functors, two concepts central to Haskell and to functional programming in general, is doubly amazing.</p>
<h1 id="wrapping-up">Wrapping Up</h1>
<p>Top-down and bottom-up traversals are the simplest of recursion schemes—we’ve barely touched the surface of what <em>Bananas, Lenses, Envelopes, and Barbed Wire</em> has to offer us. In the next installment of this series I’ll explore the myriad varieties of recursion schemes—apomorphisms, paramorphisms, and histomorphisms, just to name a few—and how generalizing each recursion scheme allows us to derive new, more-general schemes.</p>
<p>I’d like to thank everyone who read a draft of this entry, especially Nate Soares and Manuel Chakravarty. I’d also like to thank Colin Barrett, who helped me puzzle all this out over late-night Skype sessions. If you have any comments or questions, please drop me a line on <a href="https://twitter.com/importantshock">Twitter</a>.</p>
<p><em>In the next installment of this series, we go on to discuss <a href="https://blog.sumtypeofway.com/recursion-schemes-part-2/">catamorphisms and anamorphisms</a>.</em></p>
                </section>
            </article>
        </div>
    </body>

</html>
