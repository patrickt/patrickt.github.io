<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8" />
        <meta name="author" content="Patrick Thomson" />
        <link rel="stylesheet" type="text/css" href="../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>
            adventures in uncertainty: Recursion Schemes, Part 4½: Better Living Through Base Functors
        </title>
    </head>


    <body>
        <div id="header">
            <a href="../">home</a>
            <a href="../archive.html">archive</a>
            <a href="../atom.xml">feed</a>
        </div>
        <div id="content">
            <article>
                <h1>Recursion Schemes, Part 4½: Better Living Through Base Functors</h1>
                
                
                  <h3 class="numeral">2018-01-24</h3>
                
                <section>
                    <p>In an effort to publish more than one blog post a year, I’ve decided to write about smaller topics. Today I’m going to talk about the notion of a ‘base functor’, and how the popular <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> library uses base functors to make recursion schemes more elegant and ergonomic in practice.</p>
<h1 id="repeating-ourselves">Repeating Ourselves</h1>
<p>Throughout this series of posts, we’ve seen the pattern of parameterizing our data types in terms of a recursive type variable. In the first installment, we went from this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Index</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Call</span> <span class="dt">Expr</span> [<span class="dt">Expr</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Unary</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Binary</span> <span class="dt">Expr</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Paren</span> <span class="dt">Expr</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Literal</span> <span class="dt">Int</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>to this—the same data type, but of kind<span><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle" /><span class="sidenote">If you’re not familiar with the notion of a ‘kind’, you can think (loosely) about the kind of a data type <code>t</code> as a measure of how many arguments it takes. Our <code>Expr</code> type takes no arguments, so its kind is “star”: <code>*</code>. A data type that takes one argument has kind ‘star to star’, <code>* -&gt; *</code>. A data type that takes three arguments, like <code>Either</code>, has kind <code>* -&gt; * -&gt; *</code>. The high-level description of a kind is ‘the type of a type’, but you can think about them as merely providing information as to the parameters taken, if any, by a data type. (The <code>:k</code>) directive in GHCi provides information on the kind of any type or typeclass you provide.<br />
<br />
</span></span> <code>* -&gt; *</code>, with all recursive occurrences of the <code>Expr</code> type replaced with the type variable <code>a</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ExprF</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Index</span> a a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Call</span> a [a]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Unary</span> <span class="dt">String</span> a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Binary</span> a <span class="dt">String</span> a</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Paren</span> a</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Literal</span> <span class="dt">Int</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>We then used the <code>Term</code> trick, a Y-combinator for the type system, to parameterize <code>ExprF</code> in terms of itself, yielding a data type equivalent to the original <code>Expr</code> but that can be mapped over with <code>fmap</code> and folded with <code>cata</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Term</span> f <span class="ot">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> f (<span class="dt">Term</span> f) }</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">ExprF</span> (<span class="dt">Term</span> <span class="dt">ExprF</span>)</span></code></pre></div>
<p>Similarly, in part 4 we represented the natural numbers with a data type of kind <code>* -&gt; *</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Nat</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">Next</span> a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>And we represented the <code>Plant</code> type we grow with another such data type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Plant</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Root</span> a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Stalk</span> a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Fork</span> a a a</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Bloom</span></span></code></pre></div>
<p>This is a good and fluent way to build data types. However, it has its disadvantages.</p>
<p>Consider the humble linked list, containing values of type <code>a</code>: <code>[a]</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">data</span> [] a <span class="ot">=</span> a <span class="op">:</span> [a]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>          <span class="op">|</span> []</span></code></pre></div>
<p>Certainly <code>cata</code>, the fundamental right-fold operation, should be able to support folding over this structure: after all, it’s of kind <code>* -&gt; *</code>. But if we apply <em>Term</em> to this data type, we run into trouble quite quickly: we <em>lose the ability to store elements in a list</em>. The type variable <code>a</code> can only hold nested <code>Term a</code> values: there is no place we can actually store list elements. This is, as you can tell, not particularly useful.</p>
<p>Now, of course, we can do our standard song-and-dance routine, converting <code>[a]</code> into a type where its recursive element is replaced by a new type variable to represent recursive occurrences (the <code>[a]</code> in the <code>(:)</code> constructor:)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ListF</span> a b</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Cons</span> a b</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Nil</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>This looks a little different from our prior examples—it’s of kind <code>* -&gt; * -&gt; *</code>, not <code>* -&gt; *</code>—but the principle is the same. We add a new type variable, here called <code>b</code>, to represent recursive occurrences of the <code>List</code> type. And now we can fold over a list:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">listSum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Algebra</span> (<span class="dt">ListF</span> a) a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>listSum (<span class="dt">Cons</span> a b) <span class="ot">=</span> a <span class="op">+</span> b</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>listSum <span class="dt">Nil</span> <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p>But this is clumsy. There’s something fundamentally wrong if we have to write a replacement for the venerable <code>[]</code> type. Recursion schemes are meant to be elegant—manually creating alternate implementations for every recursive data type doesn’t strike me as particularly elegant. But I am, thankfully, not alone in feeling this way—the literature contains many ways to work around this. I’ll focus on the solution provided by the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> package.</p>
<h1 id="base-functors-to-the-rescue">Base Functors to the Rescue</h1>
<p>The first thing you see when you open up the <code>recursion-schemes</code> documentation is the following type family declaration:</p>
<p>This understandably intimidates a number of people, especially given its lack of documentation. But this is less forbidding then it appears, and the added mental overhead is worth it—the presence of the <code>Base</code> type family is one of the things that sets <code>recursion-schemes</code> apart from its competition in terms of ease-of-use.</p>
<p>The purpose of the <code>Base</code> type family is to tie together a standard Haskell data type—such as our original <code>Expr</code> formulation, or the humble <code>[]</code> list—with its parameterized, “base” representation. Its definition is very concise:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Base</span><span class="ot"> t ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span></code></pre></div>
<p>While a full-fledged tutorial on type families is beyond the scope of this post (the best such reference is the <a href="https://wiki.haskell.org/GHC/Type_families">GHC wiki</a>), we can think of type families as a way to write functions on the type-level. If we were to declare a type family, and an instance of this family (analogous to an instance of a typeclass):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Something</span> t</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Something</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Bar</span></span></code></pre></div>
<p>then anywhere we encounter the invocation <code>Something Foo</code> the GHC type system will resolve that to <code>Bar</code>. While this may seem unnecessary—if you mean <code>Bar</code>, why not just write <code>Bar</code>?—it provides us a rich facility with which to <em>associate</em> a type with another.</p>
<p>Look at the definition of <code>Base</code> again. The kind signature there indicates that, whenever you pass in a concrete type as the variable <code>t</code>, you will yield a data type parameterized with one additional variable. This corresponds to our experience with <code>ExprF</code> and <code>List</code>: <code>Expr</code> went from kind <code>*</code> to <code>* -&gt; *</code>, and <code>[a]</code> went from kind <code>* -&gt; *</code> to <code>* -&gt; * -&gt; *</code>.</p>
<p>The <code>Base</code> type family doesn’t tell us much on our own. The most illustrative path open to us is to look at an instance declared with <code>Base</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> [a] <span class="ot">=</span> <span class="dt">ListF</span> a</span></code></pre></div>
<p>This declares a type family instance. Anywhere we mean to read <code>ListF a</code>, we can write <code>Base [a]</code>. This provides important organizational meaning: there is only one sensible parameterized implementation for any recursive type, and thus (thanks to Haskell’s support for type families) there is only one implementation of <code>Base a</code> for any given type <code>a</code>.</p>
<p>This isn’t particularly exciting on its own. The real fireworks start here, with the definition (simplified here for pedagogical purposes) of the <code>Recursive</code> typeclass.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">class</span> (<span class="dt">Functor</span> (<span class="dt">Base</span> t)) <span class="ot">=&gt;</span> <span class="dt">Recursive</span> t <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">  project ::</span> t <span class="ot">-&gt;</span> <span class="dt">Base</span> t t</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="ot">  cata    ::</span> (<span class="dt">Base</span> t a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>The <code>Recursive</code> typeclass is similar to the <code>Foldable</code> typeclass<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">As you can see by the name of its containing module, <code>Data.Functor.Foldable</code>. This class was originally called <code>Foldable</code>, but the presence of <code>Foldable</code> in the standard library made the duplication unsupportable, and it was changed to <code>Recursive</code>.<br />
<br />
</span></span>. The analogy holds: if we define a <code>Recursive</code> instance for our data type <code>t</code>, whether that’s <code>Expr</code> or <code>[a]</code> or anything else, we can fold over this type. However, instead of providing a simple fold, we provide two functions: a <code>project</code> function that takes a type <code>t</code> and returns the same type but transformed into its <code>Base</code> form, and a <code>cata</code> function that, given an algebra from <code>Base t a</code> to <code>a</code> (to wit: <code>Base t a -&gt; a</code>), and an initial <code>t</code> value over which to fold, yields us a folded <code>a</code> value.</p>
<p>This is, at first glance, more unwieldy than our formulation of <code>cata</code>, which only involved a <code>Functor</code> constraint, and nothing related to <code>Base</code> functors or a new <code>Recursive</code> type:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">cata ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>cata f <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (cata f) <span class="op">&gt;&gt;&gt;</span> f</span></code></pre></div>
<p>But, critically, this formulation of <code>cata</code> forces us to work with <code>Term List</code> rather than the simple <code>[a]</code>. However, <code>Recursive</code> allows us to work with ordinary data types: rather than provide a <code>Term t</code> to <code>cata</code>, we give an ordinary <code>t</code>. <code>Recursive</code> instances <em>use the <code>project</code> function to transform the provided type into a parameterized one</em>, then pass that transformed data type to the <code>cata</code> function. As such, we can now use <code>cata</code> to fold over an ordinary list, without having to wrap it in <code>Term</code> and <code>Cons</code> values.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">sumList ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>sumList <span class="ot">=</span> cata go <span class="kw">where</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  go <span class="dt">Nil</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  go (<span class="dt">Cons</span> a acc) <span class="ot">=</span> a <span class="op">+</span> acc</span></code></pre></div>
<p><code>Recursive</code> has further tricks up its sleeve. Thanks to a <code>MINIMAL</code> pragma, the <code>Recursive</code> class only needs an implementation of <code>project</code> to implement <code>Recursive</code> fully—we still get a universal <code>cata</code> function for free. The implementation looks like this, if you’re interested:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Functor</span> (<span class="dt">Base</span> t) <span class="ot">=&gt;</span> <span class="dt">Recursive</span> t <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="ot">  project ::</span> t <span class="ot">-&gt;</span> <span class="dt">Base</span> t t</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="ot">  cata ::</span> (<span class="dt">Base</span> t a <span class="ot">-&gt;</span> a)  <span class="co">-- ^ a (Base t)-algebra</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>       <span class="ot">-&gt;</span> t               <span class="co">-- ^ fixed point</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>       <span class="ot">-&gt;</span> a               <span class="co">-- ^ result</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  cata f <span class="ot">=</span> c <span class="kw">where</span> c <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> c <span class="op">.</span> project</span></code></pre></div>
<p>Note that the <code>cata</code> function is given a default definition. If you had some magic data type that admitted a faster <code>cata</code> than the default implementation, you could override it—however, I struggle to think of a type which would admit a custom <code>cata</code>.</p>
<p>Contained inside the <code>Recursive</code> class are other useful folds—<code>para</code>, the paramorphism, which we discussed in part 3, and ones we haven’t covered yet—the generalized paramorphism <code>gpara</code> and Fokkinga’s prepromorphism <code>prepro</code>. (We will discuss these in a future installment).</p>
<p>Note that the Base type is constrained in Recursive instances: <code>t</code> must have a <code>Base</code> instance, and the <code>Base</code> instance for <code>t</code> must be a <code>Functor</code>. Since <code>cata</code> is defined in terms of a recursive invocation with <code>fmap</code>, we need a useful <code>fmap</code> function over any <code>Base</code> instance to have a <code>cata</code> that typechecks.</p>
<p>Thanks to the <code>Recursive</code> typeclass, we can deal in simple data types—<code>[a]</code> rather than <code>ListF</code>, <code>Expr</code> rather than <code>ExprF</code>—while retaining the expressive folding power granted by paramterized data types. This is cool as hell. This technique is used in other libraries, such as José Pedro Magalhães’s <a href="https://hackage.haskell.org/package/regular/docs/Generics-Regular-Base.html#t:PF"><code>regular</code></a>.</p>
<p>The implementation of <code>Recursive</code> for <code>[a]</code> follows. We convert the empty list <code>[]</code> into <code>Nil</code>, and replace <code>:</code> with the <code>Cons</code> constructor.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Recursive</span> [a] <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>  project (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Cons</span> x xs</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  project [] <span class="ot">=</span> <span class="dt">Nil</span></span></code></pre></div>
<p>Another valuable instance is one for <code>Natural</code>—as we discussed in the previous installment, we can fold over the natural numbers, bottoming out when we hit zero. We built our own <code>Nat</code> data type, observing that it was equivalent in definition to <code>Maybe</code>—<code>recursion-schemes</code> just uses <code>Maybe</code> for its <code>Recursive</code> and <code>Base</code> instance for <code>Natural</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> <span class="dt">Natural</span> <span class="ot">=</span> <span class="dt">Maybe</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Recursive</span> <span class="dt">Natural</span> <span class="kw">where</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  project <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  project n <span class="ot">=</span> <span class="dt">Just</span> (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<h1 id="yet-more-concision">Yet More Concision</h1>
<p>As we’ve mentioned before, given a data type <code>t</code>, the steps for constructing its <code>Base</code> instance are straightforward: add a new type variable to the definition, and for each data constructor, create a new constructor with all recursive occurrences of <code>t</code> replaced by the new type variable.</p>
<p>Thanks to the magic of Template Haskell, <code>recursion-schemes</code> can generate this code for us:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Functor.Foldable.TH</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Index</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Call</span> <span class="dt">Expr</span> [<span class="dt">Expr</span>]</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Unary</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Binary</span> <span class="dt">Expr</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Paren</span> <span class="dt">Expr</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Literal</span> <span class="dt">Lit</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>makeBaseFunctor '<span class="dt">'Expr</span></span></code></pre></div>
<p>The <code>makeBaseFunctor</code> call generates code equivalent to the following:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ExprF</span> a</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">IndexF</span> a a</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">CallF</span> a [a]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">UnaryF</span> <span class="dt">String</span> a</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">BinaryF</span> a <span class="dt">String</span> a</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">ParenF</span> a</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">LiteralF</span> <span class="dt">Lit</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">ExprF</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Recursive</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>  project (<span class="dt">Index</span> a b) <span class="ot">=</span> <span class="dt">IndexF</span> a a</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>  project (<span class="dt">Call</span> a b)  <span class="ot">=</span> <span class="dt">CallF</span> a a</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>  <span class="co">-- and so on and so forth</span></span></code></pre></div>
<p>This is the result of applying the aforementioned algorithm to our <code>Expr</code> type. To avoid name collisions, constructor names are suffixed with an ‘F’. (Infix operators are suffixed with a <code>$</code>).</p>
<p>The inclusion of these Template Haskell splices means that you, the programmer, can pick up the <code>recursion-schemes</code> library with a minimum of fuss and boilerplate. This is, in my experience writing Haskell in production, truly invaluable when dealing with nested data types: you can fold beautifully without setting up dozens of lines of boilerplate.</p>
<h1 id="reversing-the-arrows-again">Reversing the Arrows, Again</h1>
<p>In part two of this series, we generated an unfold by ‘reversing the arrows’ in <code>cata</code>. As you might be able to infer from the title of this section, we can do the same for <code>Recursive</code>, which yields us a <code>Corecursive</code> typeclass for unfolds:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Functor</span> (<span class="dt">Base</span> t) <span class="ot">=&gt;</span> <span class="dt">Corecursive</span> t <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="ot">  embed ::</span> <span class="dt">Base</span> t t <span class="ot">-&gt;</span> t</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="ot">  ana ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Base</span> t a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> t</span></code></pre></div>
<p>We’ve already reversed the arrows and generated <code>ana</code> from <code>cata</code>. The only thing left to do is reverse the arrows in <code>project</code>, yielding <code>embed</code>—rather than going from a <code>t</code> to a <code>Base</code> functor, as <code>project</code> does, we go from a <code>Base</code> functor to a <code>t</code>.</p>
<p>As with <code>cata</code>, <code>ana</code> is defined in terms of <code>fmap</code> and <code>embed</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Functor</span> (<span class="dt">Base</span> t) <span class="ot">=&gt;</span> <span class="dt">Corecursive</span> t <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="ot">  embed ::</span> <span class="dt">Base</span> t t <span class="ot">-&gt;</span> t</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>  ana</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Base</span> t a) <span class="co">-- ^ a (Base t)-coalgebra</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>    <span class="ot">-&gt;</span> a               <span class="co">-- ^ seed</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>    <span class="ot">-&gt;</span> t               <span class="co">-- ^ resulting fixed point</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  ana g <span class="ot">=</span> a <span class="kw">where</span> a <span class="ot">=</span> embed <span class="op">.</span> <span class="fu">fmap</span> a <span class="op">.</span> g</span></code></pre></div>
<p>Instances for <code>embed</code> are similarly straightforward:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Corecursive</span> [a] <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  embed (<span class="dt">Cons</span> x xs) <span class="ot">=</span> x<span class="op">:</span>xs</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  embed <span class="dt">Nil</span> <span class="ot">=</span> []</span></code></pre></div>
<p>In practice, you won’t need to write your own <code>Corecursive</code> instances, as <code>makeBaseFunctor</code> creates both <code>Recursive</code> and <code>Corecursive</code> instances.</p>
<h1 id="one-more-aside">One More Aside</h1>
<p>Particularly alert readers will notice that the definition for <code>cata</code> provided by Kmett in <code>recursion-schemes</code> is slightly different from ours. Our definition used partial application of <code>cata</code> in its definition—<code>cata f</code>, being partially applied to <code>f</code>, can be passed to <code>fmap</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">cata ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>cata f <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (cata f) <span class="op">&gt;&gt;&gt;</span> f</span></code></pre></div>
<p>By contrast, Kmett’s <code>cata</code> uses a where-clause to capture <code>cata f</code> with a specific name, <code>c</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="ot">cata ::</span> (<span class="dt">Base</span> t a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> a</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>cata f <span class="ot">=</span> c <span class="kw">where</span> c <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> c <span class="op">.</span> project</span></code></pre></div>
<p>Both formulations of <code>cata</code> are defined point-free, but Kmett’s struck me as somewhat unusual— the name <code>c</code> appears unnecessary, given that you can just pass <code>cata f</code> to <code>fmap</code>. It took several years before I inferred the reason behind this—GHC generates more efficient code if you avoid partial applications. Partially-applied functions must carry their arguments along with them, forcing their evaluation process to dredge up the applied arguments and call them when invoking the function. whereas bare functions are much simpler to invoke. (For more of the gory details, you can consult the GHC wiki page on the representation of <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects">heap objects</a>).</p>
<p>Bearing this implementation detail in mind, this formulation of <code>cata</code> is quite elegant: by naming <code>cata f</code>, we can reference it not as a partially applied function, but as a regular function. Passing that function into <code>fmap</code> generates more efficient code—usually this kind of microoptimization doesn’t matter much, but given that <code>cata</code> is invoked on every iteration of a fold, the savings add up.</p>
<h1 id="thats-all">That’s All</h1>
<p>I owe thanks to Edward Kmett, whose <code>recursion-schemes</code> library is magnificent and inspiring, and to Austin Seipp, who checked my statements about GHC code generation for accuracy.</p>
<p><em>In part V, we discuss <a href="https://blog.sumtypeofway.com/recursion-schemes-part-v/">refolds—hylomorphisms and Elgot algebras</a>.</em></p>
                </section>
            </article>
        </div>
    </body>

</html>
