<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8" />
        <meta name="author" content="Patrick Thomson" />
        <link rel="stylesheet" type="text/css" href="../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>
            adventures in uncertainty: Recursion Schemes, Part III: Folds in Context
        </title>
    </head>


    <body>
        <div id="header">
            <a href="../">home</a>
            <a href="../archive.html">archive</a>
            <a href="../about.html">about</a>
            <a href="../contact.html">contact</a>
            <a href="../atom.xml">feed</a>
        </div>
        <div id="content">
            <article>
                <h1>Recursion Schemes, Part III: Folds in Context</h1>
                
                  <h2>2016-07-20</h2>
                
                <section>
                    <p>On the <a href="http://blog.sumtypeofway.com/recursion-schemes-part-2/">last episode</a> of this exploration of recursion schemes, we defined the catamorphism, our first generalized fold operation over any recursive data structure. Catamorphisms admit a beautiful definition and are useful in hosts of situations. But they have their limits: in this installment, we’ll explore these limits, and we’ll discuss how to get around them by introducing a more powerful construct—the paramorphism.</p>
<h1 id="a-refresher">A Refresher</h1>
<p>In the past two posts, we defined a datatype <code>Term</code> that represents the fixed-point of a functor <code>f</code>, with an <code>In</code> constructor that ties an <code>f (Term f)</code> into a <code>Term f</code>, and an <code>out</code> deconstructor that unties a <code>Term f</code> into an <code>f (Term f)</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Term</span> f <span class="ot">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> f (<span class="dt">Term</span> f) }</span></code></pre></div>
<p>Using <code>fmap</code>, and the property that <code>fmap</code> is the identity function over a <code>Functor</code> with no children, we can define a <code>bottomUp</code> function that applies a type-preserving transformation to any <code>Term f</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">bottomUp ::</span> <span class="dt">Functor</span> a <span class="ot">=&gt;</span> (<span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>bottomUp fn <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  out                    <span class="co">-- 1) unpack</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (bottomUp fn) <span class="co">-- 2) recurse</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="op">&gt;&gt;&gt;</span> <span class="dt">In</span>                 <span class="co">-- 3) repack</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="op">&gt;&gt;&gt;</span> fn                 <span class="co">-- 4) apply</span></span></code></pre></div>
<p>And, when we omit the repacking stage in the above definition, we yield <code>cata</code>, a generalized fold operator that allows us to collapse a given <code>Term f</code> into an accumulated value <code>a</code>, using an <code>Algebra</code> that reunites an <code>f a</code> into an <code>a</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="ot">=</span> f a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="ot">cata ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>cata fn <span class="ot">=</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    out                <span class="co">-- 1) unpack</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (cata fn) <span class="co">-- 2) recurse</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    <span class="op">&gt;&gt;&gt;</span> fn             <span class="co">-- 3) apply</span></span></code></pre></div>
<h1 id="paramorphisms">Paramorphisms</h1>
<p>Catamorphisms are simple and elegant, but in many real-world use-cases they are insufficient. For example, though the function we pass to <code>cata</code> allows us to view the data we’re transformating, it loses information about the original structure: in the case of pretty-printing, we only have access to the currently-printed tree (the <code>f Doc</code> for any fix): any information about the structure of the original <code>Term Expr</code> is lost, as it has already been pretty-printed.</p>
<p>This would be a problem if you wanted to print, say, zero-argument functions in a different manner than other functions: you’d have to use <code>==</code> to examine the <code>Doc</code> type, then dispatch on the result to implement this different behavior. And your <code>Doc</code> type may omit an <code>Eq</code> instance, so <code>==</code> may not even be possible. (Besides, looking at the pretty-printed results to infer their inputs is clumsy at best and often inaccurate in the presence of hyphenation or spacing.)</p>
<p>It would be ideal if our <code>Algebra</code> could, when examining an <code>Expr</code> node, have access both to its pretty-printed representation and its original representation as a <code>Term</code>—an <code>Algebra</code> that has access to the original, un-transformed datum, represented as its fixed-point <code>Term</code>. That is to say, whereas <code>Algebra</code> is a function from a container <code>f</code> of <code>a</code>, we want a function from container that holds <em>both</em> a <code>Term f</code> and its corresponding <code>a</code>. Rather than using a function with two arguments, we’ll bundle these two arguments together in a tuple (for reasons that will become clear later).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>f (<span class="dt">Term</span> f, a) <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Algebras that carry this extra information are known as <em>R-algebras</em>.</p>
<div class="sourceCode" id="cb5" data-tangle="../src/Part3.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">RAlgebra</span> f a <span class="ot">=</span> f (<span class="dt">Term</span> f, a) <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>There is another type of morphism that allows you to traverse a structure with an R-algebra: the <em>paramorphism</em>. As with previous examples, I’m going to explicate the etymology in the hope that it slightly illuminates a complicated concept: the <em>para</em> in paramorphism is the same as in <em>parallel</em>—from the Greek παρά, meaning “beside”, “next to”, or “alongside”<span><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle" /><span class="sidenote">Modern English tends to use “para” as a prefix meaning “pseudo” or “abnormal” (as in “parapsychology” or “paresthesia”)—this is an extension of the “alongside” meaning, implying that abnormal things appear alongside normal things. Be sure not to confuse these two meanings—there’s nothing abnormal or second-class about paramorphisms.<br />
<br />
</span></span>. A paramorphism is like a catamorphism except that it can view the original structure <em>beside</em> the structure that is being transformed.</p>
<p>So, let’s implement paramorphisms. They’ll look like the catamorphism we already discussed. But instead of just directly recursing into the structure with <code>fmap para</code>, we have to recurse with a function that returns a tuple, one that contains both the <code>Term</code> we’re recursing into and the result of recursively applying <code>para</code>. We do this here with a helper function called <code>fanout</code>, which takes a <code>Term f</code> and returns both items in which we are interested: the <code>Term</code> itself, and the result of recursively applying <code>para</code>.</p>
<div class="sourceCode" id="cb6" data-tangle="../src/Part3.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">para ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">RAlgebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>para rAlg <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> fanout <span class="op">&gt;&gt;&gt;</span> rAlg</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="kw">where</span> fanout t <span class="ot">=</span> (t, para rAlg t)</span></code></pre></div>
<p>And we’re done! This is the classical definition of a paramorphism. With it, we can have our cake and eat it too: we can intelligently fold over a data structure without losing any information about the original representation of said structure.</p>
<p>And Haskell comes with a function that makes expressing the above <code>fanout</code> function even more elegant than it already is. The <code>&amp;&amp;&amp;</code> combinator, provided in the <code>Control.Arrow</code> module, takes two functions<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">Technically, two <code>Categories</code>, but if you use instances of <code>Category</code> beyond <code>(-&gt;)</code> then you are way ahead of me.<br />
<br />
</span></span> <code>foo</code> and <code>bar</code> and returns another function that, when given a value <code>a</code>, returns a tuple consisting of <code>(foo a, bar a)</code>. Simply put, it combines the output of two functions.</p>
<p>Our <code>fanout</code> function, when provided with a <code>Term f</code>, needs to do two things: preserve its input in the first element of the tuple, and recurse with <code>para</code> into its input, providing the result of doing so in the second element. We can use <code>&amp;&amp;&amp;</code> to express this concisely: given a <code>Term f</code>, we preserve the element with the identity function <code>id</code>, and apply <code>para</code> recursively to the argument. Let’s express this as such:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>fanout <span class="ot">=</span> <span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> para f</span></code></pre></div>
<p>Now we can express <code>para</code> with our new, beautiful <code>fanout</code> function:</p>
<div class="sourceCode" id="cb8" data-tangle="../src/Part3.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">para' ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">RAlgebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>para' f <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (<span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> para' f) <span class="op">&gt;&gt;&gt;</span> f</span></code></pre></div>
<p>The type signatures indicate that both these formulations of paramorphisms are equivalent: which one you choose is entirely up to which one you find more aesthetically pleasing.</p>
<h1 id="obsoleting-the-catamorphism">Obsoleting the Catamorphism</h1>
<p>For extra credit: rather than using a function that takes a container of tuples (which can strike the eye as somewhat ugly), we can use one that takes two arguments, both the <code>Term f</code> and the container <code>f a</code>.</p>
<div class="sourceCode" id="cb9" data-tangle="../src/Part3.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">RAlgebra'</span> f a <span class="ot">=</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Balazs Komuves refers to this formulation as “slightly less natural” in his <a href="fixplate">Fixplate</a> library. The implementation is indeed less pleasing, as it cannot easily be expressed in a point-free fashion, but it has a nice property that we’ll explore below.</p>
<div class="sourceCode" id="cb10" data-tangle="../src/Part3.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">-- The &amp; function is reverse function application,</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">-- just like the $ operator, but with its arguments flipped.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="ot">para'' ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">RAlgebra'</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>para'' alg t <span class="ot">=</span> out t <span class="op">&amp;</span> <span class="fu">fmap</span> (para'' alg) <span class="op">&amp;</span> alg t</span></code></pre></div>
<p>And just as we were able to represent <code>bottomUp</code> in terms of <code>cata</code>, we can express <code>cata</code> in terms of <code>para'</code>—after all, /a catamorphism is merely a paramorphism that ignores the provided <code>Term</code>. And Haskell provides the <code>const</code> function (aka the K-combinator) for just these situations where we want to ignore an argument to a function:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">cata' ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>cata' f <span class="ot">=</span> para'' (<span class="fu">const</span> f)</span></code></pre></div>
<p>Beautiful, no? This is one of the really appealing things about recursion schemes: as we explore more and more powerful constructs, we see how the less-powerful constructs can be implemented straightforwardly in terms of more general ones.</p>
<h1 id="exempli-gratia">Exempli Gratia</h1>
<p>The identity function <code>id</code>, by definition, returns its argument unchanged: <code>id x</code> can be replaced with <code>x</code> in every case. Let’s imagine a pretty-printer that, for some reason<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">It would be a bad idea to put this optimization step in your pretty-printer—you’d either perform this as an optimization over the original code or during a conversion to a separate intermediate representation—but I’m going to stick with this incredibly contrived example, because the <code>Doc</code> type makes it very clear, when operating on <code>Expr</code> types, when and where the pretty-printing step is happening.<br />
<br />
</span></span>, performs this optimization step on its output.</p>
<p>To do this with a simple catamorphism, we’d need to check every function-call’s pretty-printed name to determine whether it is <code>id</code>, then return the argument unchanged—and, as I mentioned above, our pretty-printed <code>Doc</code> representation shouldn’t even support an equality operation, so examining it is a no-go. However, we can do this easily with a paramorphism. In order to avoid having to write a bunch of tuples, I’m going to use the second representation of R-algebras above (the ternary function), and I’m going to use the <code>Expr</code> syntax tree defined in previous installments.</p>
<div class="sourceCode" id="cb12" data-tangle="../src/Part3.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">fastPretty ::</span> <span class="dt">RAlgebra'</span> <span class="dt">Expr</span> <span class="dt">Doc</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">-- All our cases, aside from the `Call` nodes in which</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="co">-- we are interested, are the same as in the pretty-printing</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">-- catamorphism in the previous installment. We just ignore</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="co">-- the first `Term` argument because it doesn't have anything we need</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="co">-- to look at.</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>fastPretty _ (<span class="dt">Literal</span> i) <span class="ot">=</span> Pretty.int i</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>fastPretty _ (<span class="dt">Ident</span> s)   <span class="ot">=</span> Pretty.text s</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="co">-- uninteresting cases omitted, blah blah blah</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a><span class="co">-- Here's where it gets interesting. We're going to look</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a><span class="co">-- at the first argument to determine  whether this is a</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a><span class="co">-- `Call` node with the function name (an `Ident`) named `id`.</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a><span class="co">-- If so, we'll just return the only argument provided.</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>fastPretty (<span class="dt">In</span> (<span class="dt">Call</span> { func <span class="ot">=</span> <span class="st">&quot;id&quot;</span> }))</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>           (<span class="dt">Call</span> {args <span class="ot">=</span> [theArg]}) <span class="ot">=</span> theArg</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a><span class="co">-- Otherwise, we won't look at the first `Term` argument,</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a><span class="co">-- and just glom the name and the parenthesized and</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a><span class="co">-- comma-separated arguments together.</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a>fastPretty _ (<span class="dt">Call</span> f args) <span class="ot">=</span> f <span class="op">&lt;&gt;</span> Pretty.parens (<span class="fu">mconcat</span> (<span class="st">&quot;,&quot;</span> <span class="ot">`Pretty.punctuate`</span> args))</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a><span class="co">-- Straightforward ALGOL-style syntax for the remaining cases</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>fastPretty _ (<span class="dt">Index</span> it idx)  <span class="ot">=</span> it <span class="op">&lt;&gt;</span> Pretty.brackets idx</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>fastPretty _ (<span class="dt">Unary</span> op it)   <span class="ot">=</span> Pretty.text op <span class="op">&lt;&gt;</span> it</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a>fastPretty _ (<span class="dt">Binary</span> l op r) <span class="ot">=</span> l <span class="op">&lt;&gt;</span> Pretty.text op <span class="op">&lt;&gt;</span> r</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a>fastPretty _ (<span class="dt">Paren</span> ex)      <span class="ot">=</span> Pretty.parens ex</span></code></pre></div>
<p>During complicated tree transformations, the context of the structure you’re transforming will eventually come into play. Catamorphisms don’t let you examine this context, but paramorphisms do.</p>
<h1 id="apomorphisms">Apomorphisms</h1>
<p>In the previous post, we defined <code>ana</code>, the anamorphism, a generalized unfold operating on any given data type to generate a <code>Term f</code>. While unfolds are a little more abstruse and less common than folds, it’s worth walking through their construction, if only to observe the generality achieved from reversing the arrows in a given morphism.</p>
<p>We expressed <code>ana</code> as the dual to <code>cata</code>, replacing instances of <code>out</code> with <code>In</code>, and replacing left-to-right function composition with the right-to-left equivalent, <code>&lt;&lt;&lt;</code> (more commonly expressed with Haskell’s <code>.</code> function)—in short, reversing the arrows of the definition.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>cata f <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (cata f) <span class="op">&gt;&gt;&gt;</span> f</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>ana f <span class="ot">=</span> <span class="dt">In</span> <span class="op">&lt;&lt;&lt;</span> <span class="fu">fmap</span> (ana f) <span class="op">&lt;&lt;&lt;</span> f</span></code></pre></div>
<p>And we defined the function argument that <code>ana</code> takes as a <code>Coalgebra</code>, seeing as how it is dual to the <code>Algebra</code> we already defined:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Coalgebra</span> f a <span class="ot">=</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="ot">ana ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> f</span></code></pre></div>
<p>It stands to reason that we can define the dual of a paramorphism—a co-paramorphism. But, as always, we have a better name for this: the dual of a paramorphism is an <em>apomorphism</em>. Just as the ana- prefix is the opposite of the cata- prefix, so the para- prefix is the opposite of the apo- prefix. In this case, apo- comes from the Greek ἀπο, meaning “away from” or “separate”, as in “apogee” (the moon being away from the earth) or “apostasy” (someone turning away from their beliefs).</p>
<p>So, let’s start by defining the categorical dual of the R-algebra. We’ve reversed the arrows in every case, so the following definition should be correct, right?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Nope</span> <span class="ot">=</span> a <span class="ot">-&gt;</span> f (<span class="dt">Term</span> f, a)</span></code></pre></div>
<p>Wrong! We have to apply the dual to every construct in the definition of <code>RAlgebra</code>. We need to reverse the direction of the function, yes, but we also need to reverse the tuple associated with the above definition. So what’s the dual of a tuple?</p>
<p>Well, let’s consider what a tuple is for. Given two arguments <code>big</code> and <code>pac</code>, a tuple bundles both of them together as <code>(big, pac)</code>. That makes sense, yes, but what can we do with both of these arguments that fits the notion of the “opposite” of holding both? Well, we can hold one or the other. And Haskell provides a concept to hold either a <code>big</code> or a <code>pac</code>: namely, <code>Either</code>. So, given that an <code>Algebra f a</code> holds a <code>Term f</code> and an <code>a</code>, we can express the dual of an R-algebra using an <code>Either</code>:</p>
<div class="sourceCode" id="cb16" data-tangle="../src/Part3.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">RCoalgebra</span> f a <span class="ot">=</span> a <span class="ot">-&gt;</span> f (<span class="dt">Either</span> (<span class="dt">Term</span> f) a)</span></code></pre></div>
<p>What does this <em>mean</em> when we’re using apomorphisms in practice? Well, it allows us to <em>separate</em> the flow of computation during our unfolds. If our R-coalgebra returns a <code>Left</code> value in which is contained a <code>Term</code>, the apomorphism will terminate and return the provided value. If it returns a <code>Right</code> value containing an <code>f a</code>, the unfold will continue onwards. This is cool! The ability to terminate during a corecursive iteration depending on the argument is a tremendously useful property—and we need no imperative constructs such as <code>break</code> or <code>throw</code>.</p>
<p>So, just as we expressed <code>ana</code> by reversing the arrows of <code>cata</code>, we can express <code>apo</code> by reversing the arrows of <code>para</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">para ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">RAlgebra'</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>para f <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> fanout <span class="op">&gt;&gt;&gt;</span> f <span class="kw">where</span> fanout <span class="ot">=</span> <span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> para f</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>apo<span class="ot"> f ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">RCoalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> f</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>apo f <span class="ot">=</span> <span class="dt">In</span> <span class="op">&lt;&lt;&lt;</span> <span class="fu">fmap</span> fanin <span class="op">&lt;&lt;&lt;</span> f <span class="kw">where</span> fanin <span class="ot">=</span> _</span></code></pre></div>
<p>It may not be immediately obvious how to implement <code>fanin</code>. But, when you reverse the arrows of the <code>fanout</code> definition above (I have omitted said reversal for brevity’s sake), you’ll discover that you yield a function that takes an <code>Either (Term f) a</code> and returns a <code>Term f</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">fanin ::</span> <span class="dt">Either</span> (<span class="dt">Term</span> f) a <span class="ot">-&gt;</span> <span class="dt">Term</span> f</span></code></pre></div>
<p>As such, our function will handle this either by applying <code>id</code> in the case of a <code>Left</code> value (as getting a <code>Term</code> means that we can just return the <code>Term</code>) and recursing with <code>apo</code> in the case of a plain old <code>a</code> value, out of which we ultimately yield a <code>Term</code>, thanks to the ultimate signature of <code>apo</code>. And Haskell’s built-in <code>either</code> function, which takes two functions and an Either and returns a result of applying the first to a <code>Left</code> case or the second to the <code>Right</code> case, allows us to express this <code>fanin</code> function beautifully. <code>id</code> does nothing the value contained inside a <code>Left</code>, returning just a <code>Term f</code>, and <code>apo f</code> continues the unfold operation when provided a <code>Right</code>:</p>
<div class="sourceCode" id="cb19" data-tangle="../src/Part3.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">apo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">RCoalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> f</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>apo f <span class="ot">=</span> <span class="dt">In</span> <span class="op">&lt;&lt;&lt;</span> <span class="fu">fmap</span> fanin <span class="op">&lt;&lt;&lt;</span> f <span class="kw">where</span> fanin <span class="ot">=</span> <span class="fu">either</span> <span class="fu">id</span> (apo f)</span></code></pre></div>
<p>Similarly, we can rewrite <code>fanin</code> with <code>|||</code>, the dual of the <code>&amp;&amp;&amp;</code> function above. (The operators here are a useful visual mnemonic: <code>&amp;&amp;&amp;</code> uses both the functions it provides, where as <code>|||</code> uses one or the other).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">apo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">RCoalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> f</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>apo f <span class="ot">=</span> <span class="dt">In</span> <span class="op">&lt;&lt;&lt;</span> <span class="fu">fmap</span> (<span class="fu">id</span> <span class="op">|||</span> apo f) <span class="op">&lt;&lt;&lt;</span> f</span></code></pre></div>
<h1 id="thats-all-folks">That’s All, Folks</h1>
<p>If you made it this far, I salute you. Next time, we’ll look at futumorphisms and histomorphisms, and uncover some seriously powerful constructs (and some seriously dubious etymologies).</p>
<p>I am indebted to Rob Rix, Colin Barrett, and Manuel Chakravarty for their input and suggestions regarding this post.</p>
<p><em>In part four, we explore <a href="https://blog.sumtypeofway.com/posts/recursion-schemes-part-4.html">histomorphisms and futumorphisms</a>.</em></p>
                </section>
            </article>
        </div>
    </body>

</html>
