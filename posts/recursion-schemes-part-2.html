<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8" />
        <meta name="author" content="Patrick Thomson" />
        <link rel="stylesheet" type="text/css" href="../stylesheet.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>
            adventures in uncertainty: Recursion Schemes, Part II: A Mob of Morphisms
        </title>
    </head>


    <body>
        <div id="header">
            <a href="../">home</a>
            <a href="../archive.html">archive</a>
            <a href="../about.html">about</a>
            <a href="../contact.html">contact</a>
            <a href="../atom.xml">feed</a>
        </div>
        <div id="content">
            <article>
                <h1>Recursion Schemes, Part II: A Mob of Morphisms</h1>
                
                  <h2>2015-08-25</h2>
                
                <section>
                    <p>On the <a href="http://patrickthomson.ghost.io/an-introduction-to-recursion-schemes/">last episode</a> of this very-infrequently-updated analysis of <em><a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Programming with Bananas, Lenses, Envelopes, and Barbed Wire</a></em>, we took a look at how to represent and traverse nested structures. This time, we’ll start getting into the meat of the paper<span><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle" /><span class="sidenote">By “meat of the paper”, I mean “the first two pages”. Have patience.<br />
<br />
</span></span>. We’ll define four simple recursion schemes, explore how they relate to each other, and I’ll offer up some example situations (both real-world and contrived) of situations that admit the use of recursion schemes.</p>
<p>We’ll start by defining a simple syntax tree, as we did last time.</p>
<div class="sourceCode" id="cb1" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Literal</span> {<span class="ot"> intVal ::</span> <span class="dt">Int</span> }</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Ident</span>   {<span class="ot"> name ::</span> <span class="dt">String</span>  }</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Index</span>   {<span class="ot"> target ::</span> a,<span class="ot"> idx ::</span> a }</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Unary</span>   {<span class="ot"> op ::</span> <span class="dt">String</span>,<span class="ot"> target ::</span> a }</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Binary</span>  {<span class="ot"> lhs ::</span> a,<span class="ot"> op ::</span> <span class="dt">String</span>,<span class="ot"> rhs ::</span> a }</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Call</span>    {<span class="ot"> func ::</span> a,<span class="ot"> args ::</span> [a] }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Paren</span>   {<span class="ot"> target ::</span> a }</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>We define two root constructors to represent the leaf nodes of the tree (<code>Literal</code> and <code>Ident</code>, wrapping <code>Int</code> and <code>String</code> values respectively) and five other constructors. Every position in which subexpressions may appear—the left-hand and right-hand sides to a binary operation, the target of a unary operation, the function and arguments in a function invocation—is represented by a value of type <code>a</code>, in terms of which Expr is defined<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">In other words, <code>Expr</code> is an inductively-defined data type of kind <code>* -&gt; *</code>.<br />
<br />
</span></span>.</p>
<p>We use the <code>DeriveFunctor</code> GHC extension to provide a definition of the <code>Functor</code> typeclass for <code>Expr</code>, which provides us with an <code>fmap</code> function. <code>fmap f</code>, applied to a given <code>Expr</code>, applies <code>f</code> to each subexpression <code>a</code>, and is the identity function when passed a <code>Literal</code> or <code>Ident</code> value, as they contain no subexpressions.</p>
<p>At this point, we can represent expressions with no subexpressions with the type <code>Expr ()</code>; for expressions at most one level of subexpressions, we can use <code>Expr (Expr ())</code>; for two, <code>Expr (Expr (Expr ())</code>, and so on and so forth. What we want is to represent an arbitrarily-nested <code>Expr</code>—in essence, an <code>Expr (Expr (Expr (Expr ...)))</code>—but, since Haskell doesn’t support infinite types, we have to resort to a least-fixed-point combinator. We call this combinator <code>Term</code>, with an <code>In</code> constructor and an <code>out</code> accessor function.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Term</span> f <span class="ot">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> f (<span class="dt">Term</span> f) }</span></code></pre></div>
<p>Now we represent arbitrarily-nestable <code>Expr</code> values with values of type <code>Term Expr</code>, obtained by applying the <code>In</code> constructor with a constructor from <code>Expr</code><span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">Packages like <a href="https://hackage.haskell.org/package/compdata">compdata</a> provide Template Haskell magic to avoid the syntactic clutter associated with applying the <code>In</code> constructor everywhere: given our above definition of <code>Expr</code>, we could use the <code>smartConstructors</code> splice to generate <code>iLiteral</code>, <code>iIdent</code>, <code>iUnary</code>, etc. functions, each of which are straightforward compositions of the constructors of <code>Expr</code> with the <code>In</code> fixed-point operator. GHC’s support for pattern synonyms can also eliminate applications of <code>In</code>.<br />
<br />
</span></span>:</p>
<div class="sourceCode" id="cb3" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>ten, add,<span class="ot"> call ::</span> <span class="dt">Term</span> <span class="dt">Expr</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>ten  <span class="ot">=</span> <span class="dt">In</span> (<span class="dt">Literal</span> { intVal <span class="ot">=</span> <span class="dv">10</span> })</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>add  <span class="ot">=</span> <span class="dt">In</span> (<span class="dt">Ident</span> { name <span class="ot">=</span> <span class="st">&quot;add&quot;</span> })</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>call <span class="ot">=</span> <span class="dt">In</span> (<span class="dt">Call</span> { func <span class="ot">=</span> add, args <span class="ot">=</span> [ten, ten]}) <span class="co">--add(10, 10)</span></span></code></pre></div>
<p>Using the <code>&gt;&gt;&gt;</code> operator for left-to-right function composition, we expressed a generalized bottom-up traversal capable of operating on any data type that implements the <a href="http://en.wikibooks.org/wiki/Haskell/The_Functor_class"><code>Functor</code></a> typeclass.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">bottomUp ::</span> <span class="dt">Functor</span> a <span class="ot">=&gt;</span> (<span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>bottomUp fn <span class="ot">=</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  out                   <span class="co">---1) unpack a `Term a` into an `a (Term a)`</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (bottomUp fn)<span class="co">---2) recurse, with fn, into the subterms</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="op">&gt;&gt;&gt;</span> <span class="dt">In</span>                <span class="co">---3) repack the `a (Term a)` into a `Term a`</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  <span class="op">&gt;&gt;&gt;</span> fn                <span class="co">---4) finally, apply fn to the packed `Term a`</span></span></code></pre></div>
<p>While this is a pleasing and concise representation of bottom-up transformations, it’s not as powerful as it could be: specifically, <code>fn</code> is limited to taking <em>and returning</em> a value of type <code>Term f</code>. We could not use <code>bottomUp</code> to count the total number of subexpressions in a tree (going from <code>Expr</code> to <code>Int</code>), nor could we transform this tree to a DOM representation (<code>Node</code>), nor could we render a term into a pretty-printed representation (<code>Doc</code>).</p>
<p>This is a direct result of the third step above: after recursing into the data structure with <code>fn</code> in step #2, we stuff it into a <code>Term</code> using the <code>In</code> constructor in step #3 before passing it to <code>fn</code>. This forces <code>fn</code> to both take and return a <code>Term</code>. What if we wrote a version of <code>bottomUp</code> that omitted that particular call to <code>In</code>? Does it typecheck?</p>
<p>You’re damn right it does:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>mystery fn <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  out                  <span class="co">---1) unpack the Term</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (mystery fn)<span class="co">---2) recursively apply `fn`</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  <span class="op">&gt;&gt;&gt;</span> fn               <span class="co">---3) apply `fn`</span></span></code></pre></div>
<p>Loading this function in <code>ghci</code> and querying its type yields the following result:</p>
<div class="sourceCode" id="cb6" data-results="output" data-exports="both"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="op">:</span>t mystery</span></code></pre></div>
<pre class="example"><code>mystery :: Functor f =&gt; (f a -&gt; a) -&gt; Term f -&gt; a
</code></pre>
<p>Cool. How does this work?</p>
<h2 id="algebras">Algebras</h2>
<p>Let’s take a closer look at that first parameter:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>This is a function type, taking as input a container<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle" /><span class="sidenote">The purists in the audience are no doubt cringing at my use of “container” to describe the capabilities of a <code>Functor</code>. As the Typeclassopedia points out, The <code>Functor</code> class is broader than just the concept of containing values: the best phrase for a <code>Functor f =&gt; f a</code> is “a value <code>a</code> within some computational context <code>f</code>. That doesn’t exactly roll off the tongue, though, so I will be using”container" throughout. Sorry, purists. (But I already lost the purists with my hand-wavy treatment of least-fixed-points and codata last time.)<br />
<br />
</span></span> <code>f</code> of values of type <code>a</code> and returning a bare value of type <code>a</code>. If we wanted to write a <code>countNodes</code> function that counts (as an <code>Int</code>) the number of subexpressions within a given <code>Term Expr</code>, <code>f</code> would be equal to <code>Expr</code> (which has a <code>Functor</code> instance), and <code>a</code> would be <code>Int</code>.</p>
<div class="sourceCode" id="cb9" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">countNodes ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>The crucial element of understanding this function is its first parameter, here <code>Expr Int</code>. It captures an <code>Expr</code> <em>in the process of transformation</em>—because subexpressions (the <code>lhs</code> and <code>rhs</code> field of <code>Binary</code>, the <code>func</code> and <code>args</code> fields of <code>Call</code>) were represented as values of the parameterized type <code>a</code>, we can capture the bottom-up nature of transformation <em>in the type itself</em>. This means that each case for <code>countNodes</code> is easy to express: merely add 1 to the sum of all the contained subexpressions.</p>
<div class="sourceCode" id="cb10" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>countNodes (<span class="dt">Unary</span> _ arg)         <span class="ot">=</span> arg <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>countNodes (<span class="dt">Binary</span> left _ right) <span class="ot">=</span> left <span class="op">+</span> right <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>countNodes (<span class="dt">Call</span> fn args)        <span class="ot">=</span> fn <span class="op">+</span> <span class="fu">sum</span> args <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>countNodes (<span class="dt">Index</span> it idx)        <span class="ot">=</span> it <span class="op">+</span> idx <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>countNodes (<span class="dt">Paren</span> arg)           <span class="ot">=</span> arg <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>And our base case for this transformation falls out easily: <code>Literal</code> and <code>Ident</code> have no subexpressions, so they just return 1:</p>
<div class="sourceCode" id="cb11" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>countNodes (<span class="dt">Literal</span> _) <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>countNodes (<span class="dt">Ident</span>   _) <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>Applying <code>mystery countNodes</code> to our example <code>add(10, 10)</code> datum should yield 4 (one for the identifier <code>add</code>, one for the function call, and two for the . Does it?</p>
<div class="sourceCode" id="cb12" data-results="output" data-exports="both"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> mystery countNodes call</span></code></pre></div>
<pre class="example"><code>4
</code></pre>
<p>Dope.</p>
<p>I had a major mental block in understanding when, in fact, the <code>countNodes</code> function was actually called, and how <code>mystery</code> managed to recurse as deeply as possible into the passed structure. The key lies in the invocation of <code>fmap</code> within <code>mystery</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="fu">fmap</span> (mystery fn)</span></code></pre></div>
<p>Because <code>fmap f</code> applies <code>f</code> to each subexpression within an <code>Expr</code>, <code>mystery</code> starts out by recursing as deeply as possible into the <code>Term</code> it is passed, since it calls itself recursively with <code>fmap</code>. It’s almost magical how <code>mystery</code> “knows” how to stop recursing—but it lies in the definition of <code>fmap</code>. <code>fmap mystery</code> <em>is the identity function</em> over <code>Literal</code> and <code>Ident</code> values, as they do not contain any subexpressions. At this point, <code>mystery</code> stops recursing, applies the function <code>f</code>, and returns into its previous invocations. As the stack unwinds, <code>fn</code> gets applied to the next-highest node in the tree, then the next, then the next, until all the original <code>Expr</code> values are gone and we yield only an <code>a</code>. It all comes down to the capabilities of <code>fmap</code>—from a straightforward purpose and declaration emerges a deep and subtle way to fold over a structure.</p>
<p>Indeed, functions of type <code>f a -&gt; a</code> are so ubiquitous that we refer to them by their own name:</p>
<div class="sourceCode" id="cb15" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="ot">=</span> f a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>When you see a value of type <code>Algebra f a</code>, know that it’s a function from a container <code>f</code> to a collapsed value <code>a</code>. We could rewrite the type signature of the above <code>countNodes</code> function to use it:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">countNodes ::</span> <span class="dt">Algebra</span> <span class="dt">Expr</span> <span class="dt">Int</span></span></code></pre></div>
<p>The use of the term “algebra” to in this context may seen a bit discomfiting. Most people use the term “algebra” to describe manipulating numerical expressions (as well as the associated drudgery of childhood math courses). Why are we overloading this term to represent a class of functions?</p>
<p>The etymology of “algebra” can shed some light on this—it stems from the Arabic root جبر, <em>jabr</em>, which means “restoration” or “reunion”. An algebra as a function that <em>reunites</em> a container of <code>a</code>’s—an <code>f a</code>—into a single accumulated <code>a</code> value.</p>
<h2 id="catamorphisms">Catamorphisms</h2>
<p>So, now that we have a grasp on what an algebra is and why we’re calling it that, let’s rewrite the type signature of <code>mystery</code> using the <code>Algebra</code> type synonym.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">mystery ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>This <code>mystery</code> function is known as a <em>catamorphism</em>, usually given the name <code>cata</code>:</p>
<div class="sourceCode" id="cb18" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">cata ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>cata f <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (cata f) <span class="op">&gt;&gt;&gt;</span> f</span></code></pre></div>
<p>Again, though the term “catamorphism” may seem needlessly arcane, its etymology both simplifies and clarifies its purpose: the “cata” in “catamorphism” is the same “cata” in “catastrophe”, “catabolism”, and “catalyst”—from the Greek κατα, meaning “downwards”, “into”, or “collapse”. Just as a catastophe is an unlucky event that tears things down, and catabolism is the collapse of muscle fibers, a catamorphism uses an algebra (a reunion) to collapse a container of values into a single value.</p>
<p>If you’re reminded of the <code>fold</code> operation on lists, pat yourself on the back: a list fold (specifically <code>foldr</code><span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle" /><span class="sidenote">Digression: Some of you may be wondering “if the catamorphism applied to lists is equivalent to <code>foldr</code>, what’s the analogous construct for <code>foldl</code>?” It’s not necessary: <code>foldl</code> can be expressed in terms of <code>foldr</code>, as <a href="http://okmij.org/ftp/Haskell/AlgorithmsH1.html#foldl">Oleg demonstrates</a>.<br />
<br />
</span></span>) is merely a catamorphism limited to operate on lists (the <code>[]</code> type, the archetypal <code>Functor</code>). That’s the essence of catamorphisms: they’re <em>generalized fold operations</em>, applicable to <em>any</em> functor—not just lists—all without having to write a line of boilerplate traversals and without sacrificing a mote of type safety.</p>
<p>Another excellent example of catamorphisms is pretty-printers for trees. If the representation you require of a tree type can be expressed in a purely bottom-up manner—that is to say, it requires no information about the original structure of the tree being transformed—you can express pretty-printing functions in a truly wonderfully concise manner. (Spoiler alert: later on, we’ll figure out how to do this even when you need access to the original structure.) We can describe a pretty-printing algebra from <code>Expr</code> to <code>Doc</code>, an abstract document type provided by the <a href="https://hackage.haskell.org/package/pretty-1.1.1.0/docs/Text-PrettyPrint.html">Text.PrettyPrint</a> module.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.PrettyPrint</span> (<span class="dt">Doc</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.PrettyPrint</span> <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="ot">prettyPrint ::</span> <span class="dt">Algebra</span> <span class="dt">Expr</span> <span class="dt">Doc</span></span></code></pre></div>
<p>Again, expanding the type synonym yields us a function type, going from <code>Expr</code> values containing <code>Doc</code> values as their subexpressions, out to a final <code>Doc</code> value. These values represent the leaves of the nodes that have already been pretty-printed.</p>
<div class="sourceCode" id="cb20" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">prettyPrint ::</span> <span class="dt">Expr</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span></span></code></pre></div>
<p>Our base cases are straightforward:</p>
<div class="sourceCode" id="cb21" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>prettyPrint (<span class="dt">Literal</span> i) <span class="ot">=</span> P.int i</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>prettyPrint (<span class="dt">Ident</span> s) <span class="ot">=</span> P.text s</span></code></pre></div>
<p>And our inductively-defined cases are beautifully clutter-free:</p>
<div class="sourceCode" id="cb22" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">-- f(a,b...)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>prettyPrint (<span class="dt">Call</span> f as)     <span class="ot">=</span> f <span class="op">&lt;&gt;</span> P.parens (<span class="fu">mconcat</span> (P.punctuate <span class="st">&quot;,&quot;</span> as))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="co">-- a[b]</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>prettyPrint (<span class="dt">Index</span> it idx)  <span class="ot">=</span> it <span class="op">&lt;&gt;</span> P.brackets idx</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="co">-- ab</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>prettyPrint (<span class="dt">Unary</span> op it)   <span class="ot">=</span> P.text op <span class="op">&lt;&gt;</span> it</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a><span class="co">-- a op b</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>prettyPrint (<span class="dt">Binary</span> l op r) <span class="ot">=</span> l <span class="op">&lt;&gt;</span> P.text op <span class="op">&lt;&gt;</span> r</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="co">-- (a)</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>prettyPrint (<span class="dt">Paren</span> <span class="fu">exp</span>)     <span class="ot">=</span> P.parens <span class="fu">exp</span></span></code></pre></div>
<p>Applying <code>prettyPrint</code> to our example <code>call</code> datum should yield a nice representation:</p>
<div class="sourceCode" id="cb23" data-results="output" data-exports="both"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> cata prettyPrint call</span></code></pre></div>
<pre class="example"><code>add(10,10)
</code></pre>
<p>One final detail: we can represent our <code>bottomUp</code> function in terms of <code>cata</code>. Indeed, <code>bottomUp f</code> is just <code>cata f</code>, with the additional step of stuffing the accumulator value into a <code>Term</code> with <code>In</code> before handing it off to <code>f</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>bottomUp f <span class="ot">=</span> cata (<span class="dt">In</span> <span class="op">&gt;&gt;&gt;</span> f)</span></code></pre></div>
<h2 id="laws">Laws</h2>
<p>This formulation of recursive traversals sure is elegant—but elegance isn’t enough. The real reason to use catamorphisms is that every catamorphism obeys a set of laws.<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle" /><span class="sidenote">This is assuming that we’re working in a purely functional language (and that nobody’s calling out to <code>unsafePerformIO</code>).<br />
<br />
</span></span> The simplest law is the identity law:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>cata <span class="dt">In</span> ≍ <span class="fu">id</span></span></code></pre></div>
<p>This is pretty straightforward<span><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle" /><span class="sidenote">The <code>≍</code> symbol is Unicode’s <code>EQUIVALENT TO</code> glyph, and is read as such. This wouldn’t be valid Haskell syntax, unless you defined a <code>≍</code> function of your own.<br />
<br />
</span></span>. The <code>In</code> constructor, which provides the fixed-point of a functor, is the simplest algebra: given a functor <code>f</code> wrapping a <code>Term f</code>, it turns it into a <code>Term f</code>, leaving the value untouched. And iterating over the contents of a structure without changing them is clearly the identity function.</p>
<p>Catamorphisms can also <em>fuse</em>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="co">-- given alg :: f a -&gt; a</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="co">-- and func  :: f a -&gt; f</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>cata (alg <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> func) ≍ (cata alg) <span class="op">&gt;&gt;&gt;</span> func</span></code></pre></div>
<p>This is an extraordinarily powerful property of catamorphisms: in the above example, it allows you to avoid successive invocations of fmap.</p>
<p>Catamorphisms also <em>compose</em>: given an algebra over a given type</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="co">-- given alg  :: f a -&gt; a</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="co">-- and func :: f a -&gt; g a</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>cata (f <span class="op">&gt;&gt;&gt;</span> <span class="dt">In</span>) <span class="op">&gt;&gt;&gt;</span> cata g ≍ cata (f <span class="op">&gt;&gt;&gt;</span> g)</span></code></pre></div>
<p>That is to say, the result of composing two separate catamorphisms is equivalent to a single catamorphism using the combination of the contained algebras. This is amazing, almost magically so: the composition law means that when we encounter two successive calls to <code>cata</code>, we can replace them with a single call that uses, as its algebra, the composition of the previous calls’ algebras.</p>
<h2 id="anamorphisms">Anamorphisms</h2>
<p>In the last post, we defined a corresponding <code>topDown</code> method, the opposite of <code>bottomUp</code>. Furthermore, we did so by “reversing the arrows” in bottomUp: we changed the left-to-right composition operator <code>&gt;&gt;&gt;</code> to its flipped <code>&lt;&lt;&lt;</code> (which is equivalent to the <code>.</code> operator), and we flipped around all invocations of <code>out</code> to <code>In</code> and <code>In</code> to <code>out</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>bottomUp f <span class="ot">=</span> out <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (bottomUp f) <span class="op">&gt;&gt;&gt;</span> <span class="dt">In</span>  <span class="op">&gt;&gt;&gt;</span> f</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>topDown  f <span class="ot">=</span> <span class="dt">In</span>  <span class="op">&lt;&lt;&lt;</span> <span class="fu">fmap</span> (topDown  f) <span class="op">&lt;&lt;&lt;</span> out <span class="op">&lt;&lt;&lt;</span> f</span></code></pre></div>
<p>By applying this “reversing the arrows” trick, we managed to express the duality between bottom-up and top-down traversals. So what happens if we do the same to our definition of cata? Does it typecheck?</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="co">-- given that cata f = out &gt;&gt;&gt; fmap (cata f) &gt;&gt;&gt; f</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="co">-- reverse the arrows: &gt;&gt;&gt; becomes &lt;&lt;&lt;. and out becomes In</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>reversed f <span class="ot">=</span> <span class="dt">In</span> <span class="op">&lt;&lt;&lt;</span> <span class="fu">fmap</span> (what f) <span class="op">&lt;&lt;&lt;</span> f</span></code></pre></div>
<p>It does! What’s its type signature?</p>
<div class="sourceCode" id="cb31" data-results="output" data-exports="both"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="op">:</span>t reversed</span></code></pre></div>
<pre class="example"><code>what :: (Functor f) =&gt; (a -&gt; f a) -&gt; a -&gt; Term f
</code></pre>
<p>Just as when we yielded a top-down traversal by reversing a bottom-up one, we yield an unfold when we reverse the arrows in our generalized fold function. Again, let’s take a look at the type of the first parameter, the unfolding function:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a)</span></code></pre></div>
<p>Similar to our Algebra type <code>a -&gt; f a</code>, right? Exactly the same, except the direction of the function arrow has reversed: whereas algebras are mappings from <code>f a</code> to <code>a</code>, this new function type maps as to f as. We call this function type a coalgebra.</p>
<div class="sourceCode" id="cb34" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Coalgebra</span> f a <span class="ot">=</span> a <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>We call the what an anamorphism – the “ana” prefix, from the Greek “ἀνά” meaning “building”<span><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle" /><span class="sidenote"><em>Anabolic</em> steroids build muscle mass, <em>anagenesis</em> is the development (the building, in a sense) of new species, &amp;c &amp;c.<br />
<br />
</span></span>, is the opposite of “cata”, meaning “destruction”. Just like cata generalized fold from lists to any Functor, ana generalizes unfold to any Functor.</p>
<div class="sourceCode" id="cb35" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="ot">ana ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> f</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>ana f <span class="ot">=</span> <span class="dt">In</span> <span class="op">&lt;&lt;&lt;</span> <span class="fu">fmap</span> (ana f) <span class="op">&lt;&lt;&lt;</span> f</span></code></pre></div>
<p>If we thought about algebras as reunions, we can think about coalgebras as disassembly or dispersion. We’re taking one established a value and stuffing it inside a context <code>f</code>. If that <code>f</code> is <code>Maybe</code>, then we’re allowing for the possibility that no value will be present; if that <code>f</code> is a list data type, it means we’re allowing there to be zero or more results.</p>
<p>Just as <code>cata</code> is a generalized version of the <code>foldr</code> function on list values, <code>ana</code> is a generalization of <code>unfoldr</code>. In our previous examples, we used <code>cata</code> to destroy a <code>Term Expr</code>; here, we’ll use <code>ana</code> to build one, consisting of <code>n</code> nested values.</p>
<div class="sourceCode" id="cb36" data-tangle="../src/Part2.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="ot">nested ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Expr</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>nested n <span class="ot">=</span> ana go n <span class="kw">where</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span class="ot">  go ::</span> <span class="dt">Coalgebra</span> <span class="dt">Expr</span> <span class="dt">Int</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>  go <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Literal</span> n</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>  go n <span class="ot">=</span> <span class="dt">Paren</span> (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>The case for <code>0</code> is our base case: the unfold process stops there, because <code>Literal</code> nodes have no children: future invocations of <code>fmap</code> on that <code>Literal</code> node will not produce further recursion. The second case is our inductive case. Rather than an explicitly recursive call (e.g. <code>Paren (nested (n - 1))</code>), we express the desired course of our recursion by passing that <code>n - 1</code> value directly inside a <code>Paren</code> node. Remember that this <code>Coalgebra</code> is ultimately yielding a value of type <code>Expr Int</code>; by constructing that <code>Paren</code> around an <code>Int</code>, we specify that <code>ana</code> should continue the unfold by recursing and carrying on subsequent iterations with <code>n - 1</code> as the seed value.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to Colin Barrett and Rob Rix for reading drafts of this essay, and thanks to Rob for pushing me to publish it.</p>
<p>On a personal note, I am deeply grateful for all the comments I’ve received thus far, both complimentary and constructive.</p>
<p><em>In part 3, we explore the limits of catamorphisms, and address these limits with <a href="https://blog.sumtypeofway.com/posts/recursion-schemes-part-3.html">paramorphisms and apomorphisms</a>.</em></p>
                </section>
            </article>
        </div>
    </body>

</html>
